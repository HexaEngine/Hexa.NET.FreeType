// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public static unsafe partial class Extensions
	{
		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Done_FreeType<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a given FreeType library object and all of its children,<br/>
		/// including resources, drivers, faces, sizes, etc.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the target library object.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Done_FreeType")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError DoneFreeType(this FTLibrary library)
		{
			FTError ret = FreeType.DoneFreeTypeNative(library);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] byte* filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			FTError ret = FreeType.NewFaceNative(library, filepathname, faceIndex, aface);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] ref byte filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				FTError ret = FreeType.NewFaceNative(library, (byte*)pfilepathname, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			fixed (byte* pfilepathname = filepathname)
			{
				FTError ret = FreeType.NewFaceNative(library, (byte*)pfilepathname, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] string filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FTError ret = FreeType.NewFaceNative(library, pStr0, faceIndex, aface);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] byte* filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				FTError ret = FreeType.NewFaceNative(library, filepathname, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] ref byte filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				fixed (FTFace* paface = &aface)
				{
					FTError ret = FreeType.NewFaceNative(library, (byte*)pfilepathname, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (byte* pfilepathname = filepathname)
			{
				fixed (FTFace* paface = &aface)
				{
					FTError ret = FreeType.NewFaceNative(library, (byte*)pfilepathname, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font by its pathname.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// pathname ::<br/>
		/// A path to the font file.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Done_Face to destroy the created <br/>
		/// _Face object (along with<br/>
		/// its slot and sizes).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewFace(this FTLibrary library, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] string filepathname, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (FTFace* paface = &aface)
			{
				FTError ret = FreeType.NewFaceNative(library, pStr0, faceIndex, (FTFace*)paface);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Memory_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font that has been loaded into memory.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// file_base ::<br/>
		/// A pointer to the beginning of the font data.<br/>
		/// file_size ::<br/>
		/// The size of the memory chunk used by the font data.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "FT_Byte const *")] byte* fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			FTError ret = FreeType.NewMemoryFaceNative(library, fileBase, fileSize, faceIndex, aface);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Memory_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font that has been loaded into memory.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// file_base ::<br/>
		/// A pointer to the beginning of the font data.<br/>
		/// file_size ::<br/>
		/// The size of the memory chunk used by the font data.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "FT_Byte const *")] ref byte fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			fixed (byte* pfileBase = &fileBase)
			{
				FTError ret = FreeType.NewMemoryFaceNative(library, (byte*)pfileBase, fileSize, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Memory_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font that has been loaded into memory.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// file_base ::<br/>
		/// A pointer to the beginning of the font data.<br/>
		/// file_size ::<br/>
		/// The size of the memory chunk used by the font data.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "FT_Byte const *")] byte* fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				FTError ret = FreeType.NewMemoryFaceNative(library, fileBase, fileSize, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Memory_Face<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Open_Face to open a font that has been loaded into memory.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// file_base ::<br/>
		/// A pointer to the beginning of the font data.<br/>
		/// file_size ::<br/>
		/// The size of the memory chunk used by the font data.<br/>
		/// face_index ::<br/>
		/// See <br/>
		/// _Open_Face for a detailed description of this parameter.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Memory_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewMemoryFace(this FTLibrary library, [NativeName(NativeNameType.Param, "file_base")] [NativeName(NativeNameType.Type, "FT_Byte const *")] ref byte fileBase, [NativeName(NativeNameType.Param, "file_size")] [NativeName(NativeNameType.Type, "FT_Long")] int fileSize, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (byte* pfileBase = &fileBase)
			{
				fixed (FTFace* paface = &aface)
				{
					FTError ret = FreeType.NewMemoryFaceNative(library, (byte*)pfileBase, fileSize, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Open_Face<br/>
		/// <br/>
		/// :<br/>
		/// Create a face object from a given resource described by <br/>
		/// _Open_Args.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// args ::<br/>
		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>
		/// caller.<br/>
		/// face_index ::<br/>
		/// This field holds two different values.  Bits 0-15 are the index of<br/>
		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>
		/// there is only one face in the font file.<br/>
		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>
		/// fonts only, specifying the named instance index for the current face<br/>
		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>
		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>
		/// Assuming that you want to access the third named instance in face~4,<br/>
		/// `face_index` should be set to 0x00030004.  If you want to access<br/>
		/// face~4 without variation handling, simply set `face_index` to<br/>
		/// value~4.<br/>
		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>
		/// the font format of a given font resource is supported by FreeType.<br/>
		/// In general, if the `face_index` argument is negative, the function's<br/>
		/// return value is~0 if the font format is recognized, or non-zero<br/>
		/// otherwise.  The function allocates a more or less empty face handle<br/>
		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>
		/// this special case are `face->num_faces` and `face->style_flags`.<br/>
		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>
		/// number of faces within the font file.  For the negative value<br/>
		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>
		/// `face->style_flags` give the number of named instances in face 'N'<br/>
		/// if we have a variation font (or zero otherwise).  After examination,<br/>
		/// the returned <br/>
		/// _Face structure should be deallocated with a call to<br/>
		/// <br/>
		/// _Done_Face.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Each new face object created with this function also owns a default<br/>
		/// <br/>
		/// _Size object, accessible as `face->size`.<br/>
		/// One <br/>
		/// _Library instance can have multiple face objects, that is,<br/>
		/// <br/>
		/// _Open_Face and its siblings can be called multiple times using the<br/>
		/// same `library` argument.<br/>
		/// See the discussion of reference counters in the description of<br/>
		/// <br/>
		/// _Reference_Face.<br/>
		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>
		/// `args->stream` is automatically closed before this function returns<br/>
		/// any error (including `FT_Err_Invalid_Argument`).<br/>
		/// <br/>
		/// To loop over all faces, use code similar to the following snippet<br/>
		/// (omitting the error handling).<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  i, num_faces;<br/>
		/// error = FT_Open_Face( library, args, -1, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces = face->num_faces;<br/>
		/// FT_Done_Face( face );<br/>
		/// for ( i = 0; i <br/>
		/// <<br/>
		/// num_faces; i++ )<br/>
		/// {<br/>
		/// ...<br/>
		/// error = FT_Open_Face( library, args, i, <br/>
		/// &face<br/>
		/// );<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// ...<br/>
		/// }<br/>
		/// ```<br/>
		/// To loop over all valid values for `face_index`, use something similar<br/>
		/// to the following snippet, again without error handling.  The code<br/>
		/// accesses all faces immediately (thus only a single call of<br/>
		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  num_faces     = 0;<br/>
		/// FT_Long  num_instances = 0;<br/>
		/// FT_Long  face_idx     = 0;<br/>
		/// FT_Long  instance_idx = 0;<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Long  id = ( instance_idx <br/>
		/// <<br/>
		/// <<br/>
		/// 16 ) + face_idx;<br/>
		/// error = FT_Open_Face( library, args, id, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces     = face->num_faces;<br/>
		/// num_instances = face->style_flags >> 16;<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// if ( instance_idx <br/>
		/// <<br/>
		/// num_instances )<br/>
		/// instance_idx++;<br/>
		/// else<br/>
		/// {<br/>
		/// face_idx++;<br/>
		/// instance_idx = 0;<br/>
		/// }<br/>
		/// } while ( face_idx <br/>
		/// <<br/>
		/// num_faces )<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "FT_Open_Args const *")] FTOpenArgs* args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			FTError ret = FreeType.OpenFaceNative(library, args, faceIndex, aface);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Open_Face<br/>
		/// <br/>
		/// :<br/>
		/// Create a face object from a given resource described by <br/>
		/// _Open_Args.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// args ::<br/>
		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>
		/// caller.<br/>
		/// face_index ::<br/>
		/// This field holds two different values.  Bits 0-15 are the index of<br/>
		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>
		/// there is only one face in the font file.<br/>
		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>
		/// fonts only, specifying the named instance index for the current face<br/>
		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>
		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>
		/// Assuming that you want to access the third named instance in face~4,<br/>
		/// `face_index` should be set to 0x00030004.  If you want to access<br/>
		/// face~4 without variation handling, simply set `face_index` to<br/>
		/// value~4.<br/>
		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>
		/// the font format of a given font resource is supported by FreeType.<br/>
		/// In general, if the `face_index` argument is negative, the function's<br/>
		/// return value is~0 if the font format is recognized, or non-zero<br/>
		/// otherwise.  The function allocates a more or less empty face handle<br/>
		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>
		/// this special case are `face->num_faces` and `face->style_flags`.<br/>
		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>
		/// number of faces within the font file.  For the negative value<br/>
		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>
		/// `face->style_flags` give the number of named instances in face 'N'<br/>
		/// if we have a variation font (or zero otherwise).  After examination,<br/>
		/// the returned <br/>
		/// _Face structure should be deallocated with a call to<br/>
		/// <br/>
		/// _Done_Face.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Each new face object created with this function also owns a default<br/>
		/// <br/>
		/// _Size object, accessible as `face->size`.<br/>
		/// One <br/>
		/// _Library instance can have multiple face objects, that is,<br/>
		/// <br/>
		/// _Open_Face and its siblings can be called multiple times using the<br/>
		/// same `library` argument.<br/>
		/// See the discussion of reference counters in the description of<br/>
		/// <br/>
		/// _Reference_Face.<br/>
		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>
		/// `args->stream` is automatically closed before this function returns<br/>
		/// any error (including `FT_Err_Invalid_Argument`).<br/>
		/// <br/>
		/// To loop over all faces, use code similar to the following snippet<br/>
		/// (omitting the error handling).<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  i, num_faces;<br/>
		/// error = FT_Open_Face( library, args, -1, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces = face->num_faces;<br/>
		/// FT_Done_Face( face );<br/>
		/// for ( i = 0; i <br/>
		/// <<br/>
		/// num_faces; i++ )<br/>
		/// {<br/>
		/// ...<br/>
		/// error = FT_Open_Face( library, args, i, <br/>
		/// &face<br/>
		/// );<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// ...<br/>
		/// }<br/>
		/// ```<br/>
		/// To loop over all valid values for `face_index`, use something similar<br/>
		/// to the following snippet, again without error handling.  The code<br/>
		/// accesses all faces immediately (thus only a single call of<br/>
		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  num_faces     = 0;<br/>
		/// FT_Long  num_instances = 0;<br/>
		/// FT_Long  face_idx     = 0;<br/>
		/// FT_Long  instance_idx = 0;<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Long  id = ( instance_idx <br/>
		/// <<br/>
		/// <<br/>
		/// 16 ) + face_idx;<br/>
		/// error = FT_Open_Face( library, args, id, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces     = face->num_faces;<br/>
		/// num_instances = face->style_flags >> 16;<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// if ( instance_idx <br/>
		/// <<br/>
		/// num_instances )<br/>
		/// instance_idx++;<br/>
		/// else<br/>
		/// {<br/>
		/// face_idx++;<br/>
		/// instance_idx = 0;<br/>
		/// }<br/>
		/// } while ( face_idx <br/>
		/// <<br/>
		/// num_faces )<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "FT_Open_Args const *")] ref FTOpenArgs args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] FTFace* aface)
		{
			fixed (FTOpenArgs* pargs = &args)
			{
				FTError ret = FreeType.OpenFaceNative(library, (FTOpenArgs*)pargs, faceIndex, aface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Open_Face<br/>
		/// <br/>
		/// :<br/>
		/// Create a face object from a given resource described by <br/>
		/// _Open_Args.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// args ::<br/>
		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>
		/// caller.<br/>
		/// face_index ::<br/>
		/// This field holds two different values.  Bits 0-15 are the index of<br/>
		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>
		/// there is only one face in the font file.<br/>
		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>
		/// fonts only, specifying the named instance index for the current face<br/>
		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>
		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>
		/// Assuming that you want to access the third named instance in face~4,<br/>
		/// `face_index` should be set to 0x00030004.  If you want to access<br/>
		/// face~4 without variation handling, simply set `face_index` to<br/>
		/// value~4.<br/>
		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>
		/// the font format of a given font resource is supported by FreeType.<br/>
		/// In general, if the `face_index` argument is negative, the function's<br/>
		/// return value is~0 if the font format is recognized, or non-zero<br/>
		/// otherwise.  The function allocates a more or less empty face handle<br/>
		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>
		/// this special case are `face->num_faces` and `face->style_flags`.<br/>
		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>
		/// number of faces within the font file.  For the negative value<br/>
		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>
		/// `face->style_flags` give the number of named instances in face 'N'<br/>
		/// if we have a variation font (or zero otherwise).  After examination,<br/>
		/// the returned <br/>
		/// _Face structure should be deallocated with a call to<br/>
		/// <br/>
		/// _Done_Face.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Each new face object created with this function also owns a default<br/>
		/// <br/>
		/// _Size object, accessible as `face->size`.<br/>
		/// One <br/>
		/// _Library instance can have multiple face objects, that is,<br/>
		/// <br/>
		/// _Open_Face and its siblings can be called multiple times using the<br/>
		/// same `library` argument.<br/>
		/// See the discussion of reference counters in the description of<br/>
		/// <br/>
		/// _Reference_Face.<br/>
		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>
		/// `args->stream` is automatically closed before this function returns<br/>
		/// any error (including `FT_Err_Invalid_Argument`).<br/>
		/// <br/>
		/// To loop over all faces, use code similar to the following snippet<br/>
		/// (omitting the error handling).<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  i, num_faces;<br/>
		/// error = FT_Open_Face( library, args, -1, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces = face->num_faces;<br/>
		/// FT_Done_Face( face );<br/>
		/// for ( i = 0; i <br/>
		/// <<br/>
		/// num_faces; i++ )<br/>
		/// {<br/>
		/// ...<br/>
		/// error = FT_Open_Face( library, args, i, <br/>
		/// &face<br/>
		/// );<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// ...<br/>
		/// }<br/>
		/// ```<br/>
		/// To loop over all valid values for `face_index`, use something similar<br/>
		/// to the following snippet, again without error handling.  The code<br/>
		/// accesses all faces immediately (thus only a single call of<br/>
		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  num_faces     = 0;<br/>
		/// FT_Long  num_instances = 0;<br/>
		/// FT_Long  face_idx     = 0;<br/>
		/// FT_Long  instance_idx = 0;<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Long  id = ( instance_idx <br/>
		/// <<br/>
		/// <<br/>
		/// 16 ) + face_idx;<br/>
		/// error = FT_Open_Face( library, args, id, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces     = face->num_faces;<br/>
		/// num_instances = face->style_flags >> 16;<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// if ( instance_idx <br/>
		/// <<br/>
		/// num_instances )<br/>
		/// instance_idx++;<br/>
		/// else<br/>
		/// {<br/>
		/// face_idx++;<br/>
		/// instance_idx = 0;<br/>
		/// }<br/>
		/// } while ( face_idx <br/>
		/// <<br/>
		/// num_faces )<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "FT_Open_Args const *")] FTOpenArgs* args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (FTFace* paface = &aface)
			{
				FTError ret = FreeType.OpenFaceNative(library, args, faceIndex, (FTFace*)paface);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Open_Face<br/>
		/// <br/>
		/// :<br/>
		/// Create a face object from a given resource described by <br/>
		/// _Open_Args.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library resource.<br/>
		/// <br/>
		/// :<br/>
		/// args ::<br/>
		/// A pointer to an `FT_Open_Args` structure that must be filled by the<br/>
		/// caller.<br/>
		/// face_index ::<br/>
		/// This field holds two different values.  Bits 0-15 are the index of<br/>
		/// the face in the font file (starting with value~0).  Set it to~0 if<br/>
		/// there is only one face in the font file.<br/>
		/// [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation<br/>
		/// fonts only, specifying the named instance index for the current face<br/>
		/// index (starting with value~1; value~0 makes FreeType ignore named<br/>
		/// instances).  For non-variation fonts, bits 16-30 are ignored.<br/>
		/// Assuming that you want to access the third named instance in face~4,<br/>
		/// `face_index` should be set to 0x00030004.  If you want to access<br/>
		/// face~4 without variation handling, simply set `face_index` to<br/>
		/// value~4.<br/>
		/// `FT_Open_Face` and its siblings can be used to quickly check whether<br/>
		/// the font format of a given font resource is supported by FreeType.<br/>
		/// In general, if the `face_index` argument is negative, the function's<br/>
		/// return value is~0 if the font format is recognized, or non-zero<br/>
		/// otherwise.  The function allocates a more or less empty face handle<br/>
		/// in `*aface` (if `aface` isn't `NULL`); the only two useful fields in<br/>
		/// this special case are `face->num_faces` and `face->style_flags`.<br/>
		/// For any negative value of `face_index`, `face->num_faces` gives the<br/>
		/// number of faces within the font file.  For the negative value<br/>
		/// '-(N+1)' (with 'N' a non-negative 16-bit value), bits 16-30 in<br/>
		/// `face->style_flags` give the number of named instances in face 'N'<br/>
		/// if we have a variation font (or zero otherwise).  After examination,<br/>
		/// the returned <br/>
		/// _Face structure should be deallocated with a call to<br/>
		/// <br/>
		/// _Done_Face.<br/>
		/// <br/>
		/// :<br/>
		/// aface ::<br/>
		/// A handle to a new face object.  If `face_index` is greater than or<br/>
		/// equal to zero, it must be non-`NULL`.<br/>
		/// <br/>
		/// <br/>
		/// Each new face object created with this function also owns a default<br/>
		/// <br/>
		/// _Size object, accessible as `face->size`.<br/>
		/// One <br/>
		/// _Library instance can have multiple face objects, that is,<br/>
		/// <br/>
		/// _Open_Face and its siblings can be called multiple times using the<br/>
		/// same `library` argument.<br/>
		/// See the discussion of reference counters in the description of<br/>
		/// <br/>
		/// _Reference_Face.<br/>
		/// If `FT_OPEN_STREAM` is set in `args->flags`, the stream in<br/>
		/// `args->stream` is automatically closed before this function returns<br/>
		/// any error (including `FT_Err_Invalid_Argument`).<br/>
		/// <br/>
		/// To loop over all faces, use code similar to the following snippet<br/>
		/// (omitting the error handling).<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  i, num_faces;<br/>
		/// error = FT_Open_Face( library, args, -1, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces = face->num_faces;<br/>
		/// FT_Done_Face( face );<br/>
		/// for ( i = 0; i <br/>
		/// <<br/>
		/// num_faces; i++ )<br/>
		/// {<br/>
		/// ...<br/>
		/// error = FT_Open_Face( library, args, i, <br/>
		/// &face<br/>
		/// );<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// ...<br/>
		/// }<br/>
		/// ```<br/>
		/// To loop over all valid values for `face_index`, use something similar<br/>
		/// to the following snippet, again without error handling.  The code<br/>
		/// accesses all faces immediately (thus only a single call of<br/>
		/// `FT_Open_Face` within the do-loop), with and without named instances.<br/>
		/// ```<br/>
		/// ...<br/>
		/// FT_Face  face;<br/>
		/// FT_Long  num_faces     = 0;<br/>
		/// FT_Long  num_instances = 0;<br/>
		/// FT_Long  face_idx     = 0;<br/>
		/// FT_Long  instance_idx = 0;<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Long  id = ( instance_idx <br/>
		/// <<br/>
		/// <<br/>
		/// 16 ) + face_idx;<br/>
		/// error = FT_Open_Face( library, args, id, <br/>
		/// &face<br/>
		/// );<br/>
		/// if ( error ) { ... }<br/>
		/// num_faces     = face->num_faces;<br/>
		/// num_instances = face->style_flags >> 16;<br/>
		/// ...<br/>
		/// FT_Done_Face( face );<br/>
		/// if ( instance_idx <br/>
		/// <<br/>
		/// num_instances )<br/>
		/// instance_idx++;<br/>
		/// else<br/>
		/// {<br/>
		/// face_idx++;<br/>
		/// instance_idx = 0;<br/>
		/// }<br/>
		/// } while ( face_idx <br/>
		/// <<br/>
		/// num_faces )<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Open_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OpenFace(this FTLibrary library, [NativeName(NativeNameType.Param, "args")] [NativeName(NativeNameType.Type, "FT_Open_Args const *")] ref FTOpenArgs args, [NativeName(NativeNameType.Param, "face_index")] [NativeName(NativeNameType.Type, "FT_Long")] int faceIndex, [NativeName(NativeNameType.Param, "aface")] [NativeName(NativeNameType.Type, "FT_Face *")] ref FTFace aface)
		{
			fixed (FTOpenArgs* pargs = &args)
			{
				fixed (FTFace* paface = &aface)
				{
					FTError ret = FreeType.OpenFaceNative(library, (FTOpenArgs*)pargs, faceIndex, (FTFace*)paface);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			FreeType.LibraryVersionNative(library, amajor, aminor, apatch);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				FreeType.LibraryVersionNative(library, (int*)pamajor, aminor, apatch);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			fixed (int* paminor = &aminor)
			{
				FreeType.LibraryVersionNative(library, amajor, (int*)paminor, apatch);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					FreeType.LibraryVersionNative(library, (int*)pamajor, (int*)paminor, apatch);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* papatch = &apatch)
			{
				FreeType.LibraryVersionNative(library, amajor, aminor, (int*)papatch);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* papatch = &apatch)
				{
					FreeType.LibraryVersionNative(library, (int*)pamajor, aminor, (int*)papatch);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* paminor = &aminor)
			{
				fixed (int* papatch = &apatch)
				{
					FreeType.LibraryVersionNative(library, amajor, (int*)paminor, (int*)papatch);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Version(this FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					fixed (int* papatch = &apatch)
					{
						FreeType.LibraryVersionNative(library, (int*)pamajor, (int*)paminor, (int*)papatch);
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to create a new empty glyph image.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the FreeType library object.<br/>
		/// format ::<br/>
		/// The format of the glyph's image.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewGlyph(this FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* aglyph)
		{
			FTError ret = FreeType.NewGlyphNative(library, format, aglyph);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to create a new empty glyph image.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the FreeType library object.<br/>
		/// format ::<br/>
		/// The format of the glyph's image.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewGlyph(this FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph aglyph)
		{
			fixed (FTGlyph* paglyph = &aglyph)
			{
				FTError ret = FreeType.NewGlyphNative(library, format, (FTGlyph*)paglyph);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new outline of a given size.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library object from where the outline is allocated.<br/>
		/// Note however that the new outline will **not** necessarily be<br/>
		/// **freed**, when destroying the library, by <br/>
		/// _Done_FreeType.<br/>
		/// numPoints ::<br/>
		/// The maximum number of points within the outline.  Must be smaller<br/>
		/// than or equal to 0xFFFF (65535).<br/>
		/// numContours ::<br/>
		/// The maximum number of contours within the outline.  This value must<br/>
		/// be in the range 0 to `numPoints`.<br/>
		/// <br/>
		/// :<br/>
		/// anoutline ::<br/>
		/// A handle to the new outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineNew(this FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* anoutline)
		{
			FTError ret = FreeType.OutlineNewNative(library, numPoints, numContours, anoutline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new outline of a given size.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library object from where the outline is allocated.<br/>
		/// Note however that the new outline will **not** necessarily be<br/>
		/// **freed**, when destroying the library, by <br/>
		/// _Done_FreeType.<br/>
		/// numPoints ::<br/>
		/// The maximum number of points within the outline.  Must be smaller<br/>
		/// than or equal to 0xFFFF (65535).<br/>
		/// numContours ::<br/>
		/// The maximum number of contours within the outline.  This value must<br/>
		/// be in the range 0 to `numPoints`.<br/>
		/// <br/>
		/// :<br/>
		/// anoutline ::<br/>
		/// A handle to the new outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineNew(this FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline anoutline)
		{
			fixed (FTOutline* panoutline = &anoutline)
			{
				FTError ret = FreeType.OutlineNewNative(library, numPoints, numContours, (FTOutline*)panoutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy an outline created with <br/>
		/// _Outline_New.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle of the library object used to allocate the outline.<br/>
		/// outline ::<br/>
		/// A pointer to the outline object to be discarded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDone(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FTError ret = FreeType.OutlineDoneNative(library, outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy an outline created with <br/>
		/// _Outline_New.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle of the library object used to allocate the outline.<br/>
		/// outline ::<br/>
		/// A pointer to the outline object to be discarded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDone(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = FreeType.OutlineDoneNative(library, (FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* abitmap)
		{
			FTError ret = FreeType.OutlineGetBitmapNative(library, outline, abitmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* abitmap)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = FreeType.OutlineGetBitmapNative(library, (FTOutline*)poutline, abitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap abitmap)
		{
			fixed (FTBitmap* pabitmap = &abitmap)
			{
				FTError ret = FreeType.OutlineGetBitmapNative(library, outline, (FTBitmap*)pabitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap abitmap)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTBitmap* pabitmap = &abitmap)
				{
					FTError ret = FreeType.OutlineGetBitmapNative(library, (FTOutline*)poutline, (FTBitmap*)pabitmap);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] FTRasterParams* @params)
		{
			FTError ret = FreeType.OutlineRenderNative(library, outline, @params);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] FTRasterParams* @params)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = FreeType.OutlineRenderNative(library, (FTOutline*)poutline, @params);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] ref FTRasterParams @params)
		{
			fixed (FTRasterParams* pparams = &@params)
			{
				FTError ret = FreeType.OutlineRenderNative(library, outline, (FTRasterParams*)pparams);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender(this FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] ref FTRasterParams @params)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTRasterParams* pparams = &@params)
				{
					FTError ret = FreeType.OutlineRenderNative(library, (FTOutline*)poutline, (FTRasterParams*)pparams);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target)
		{
			FTError ret = FreeType.BitmapCopyNative(library, source, target);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target)
		{
			fixed (FTBitmap* psource = &source)
			{
				FTError ret = FreeType.BitmapCopyNative(library, (FTBitmap*)psource, target);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				FTError ret = FreeType.BitmapCopyNative(library, source, (FTBitmap*)ptarget);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					FTError ret = FreeType.BitmapCopyNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>
		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>
		/// kept unchanged.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// xStrength ::<br/>
		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// yStrength ::<br/>
		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// <br/>
		/// :<br/>
		/// bitmap ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// If you want to embolden the bitmap owned by a <br/>
		/// _GlyphSlotRec, you<br/>
		/// should call <br/>
		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>
		/// Bitmaps in <br/>
		/// _PIXEL_MODE_GRAY2 and <br/>
		/// _PIXEL_MODE_GRAY<br/>
		/// @<br/>
		/// format are<br/>
		/// converted to <br/>
		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapEmbolden(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			FTError ret = FreeType.BitmapEmboldenNative(library, bitmap, xStrength, yStrength);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>
		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>
		/// kept unchanged.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// xStrength ::<br/>
		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// yStrength ::<br/>
		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// <br/>
		/// :<br/>
		/// bitmap ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// If you want to embolden the bitmap owned by a <br/>
		/// _GlyphSlotRec, you<br/>
		/// should call <br/>
		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>
		/// Bitmaps in <br/>
		/// _PIXEL_MODE_GRAY2 and <br/>
		/// _PIXEL_MODE_GRAY<br/>
		/// @<br/>
		/// format are<br/>
		/// converted to <br/>
		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapEmbolden(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				FTError ret = FreeType.BitmapEmboldenNative(library, (FTBitmap*)pbitmap, xStrength, yStrength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			FTError ret = FreeType.BitmapConvertNative(library, source, target, alignment);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				FTError ret = FreeType.BitmapConvertNative(library, (FTBitmap*)psource, target, alignment);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				FTError ret = FreeType.BitmapConvertNative(library, source, (FTBitmap*)ptarget, alignment);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					FTError ret = FreeType.BitmapConvertNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget, alignment);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			FTError ret = FreeType.BitmapBlendNative(library, source, sourceOffset, target, atargetOffset, color);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				FTError ret = FreeType.BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				FTError ret = FreeType.BitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					FTError ret = FreeType.BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTVector* patargetOffset = &atargetOffset)
			{
				FTError ret = FreeType.BitmapBlendNative(library, source, sourceOffset, target, (FTVector*)patargetOffset, color);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					FTError ret = FreeType.BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					FTError ret = FreeType.BitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend(this FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					fixed (FTVector* patargetOffset = &atargetOffset)
					{
						FTError ret = FreeType.BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a bitmap object initialized with <br/>
		/// _Bitmap_Init.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// bitmap ::<br/>
		/// The bitmap object to be freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapDone(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* bitmap)
		{
			FTError ret = FreeType.BitmapDoneNative(library, bitmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a bitmap object initialized with <br/>
		/// _Bitmap_Init.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// bitmap ::<br/>
		/// The bitmap object to be freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapDone(this FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap bitmap)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				FTError ret = FreeType.BitmapDoneNative(library, (FTBitmap*)pbitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// FreeType library handle.<br/>
		/// <br/>
		/// :<br/>
		/// astroker ::<br/>
		/// A new stroker object handle.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerNew(this FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker *")] FTStroker* astroker)
		{
			FTError ret = FreeType.StrokerNewNative(library, astroker);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// FreeType library handle.<br/>
		/// <br/>
		/// :<br/>
		/// astroker ::<br/>
		/// A new stroker object handle.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerNew(this FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker *")] ref FTStroker astroker)
		{
			fixed (FTStroker* pastroker = &astroker)
			{
				FTError ret = FreeType.StrokerNewNative(library, (FTStroker*)pastroker);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Attach_File<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Attach_Stream to attach a file.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The target face object.<br/>
		/// <br/>
		/// :<br/>
		/// filepathname ::<br/>
		/// The pathname.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] byte* filepathname)
		{
			FTError ret = FreeType.AttachFileNative(face, filepathname);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Attach_File<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Attach_Stream to attach a file.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The target face object.<br/>
		/// <br/>
		/// :<br/>
		/// filepathname ::<br/>
		/// The pathname.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] ref byte filepathname)
		{
			fixed (byte* pfilepathname = &filepathname)
			{
				FTError ret = FreeType.AttachFileNative(face, (byte*)pfilepathname);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Attach_File<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Attach_Stream to attach a file.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The target face object.<br/>
		/// <br/>
		/// :<br/>
		/// filepathname ::<br/>
		/// The pathname.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] ReadOnlySpan<byte> filepathname)
		{
			fixed (byte* pfilepathname = filepathname)
			{
				FTError ret = FreeType.AttachFileNative(face, (byte*)pfilepathname);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Attach_File<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Attach_Stream to attach a file.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The target face object.<br/>
		/// <br/>
		/// :<br/>
		/// filepathname ::<br/>
		/// The pathname.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Attach_File")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError AttachFile(this FTFace face, [NativeName(NativeNameType.Param, "filepathname")] [NativeName(NativeNameType.Type, "char const *")] string filepathname)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filepathname != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filepathname);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filepathname, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			FTError ret = FreeType.AttachFileNative(face, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Attach_Stream<br/>
		/// <br/>
		/// :<br/>
		/// 'Attach' data to a face object.  Normally, this is used to read<br/>
		/// additional information for the face object.  For example, you can<br/>
		/// attach an AFM file that comes with a Type~1 font to get the kerning<br/>
		/// values and other metrics.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The target face object.<br/>
		/// <br/>
		/// :<br/>
		/// parameters ::<br/>
		/// A pointer to <br/>
		/// _Open_Args that must be filled by the caller.<br/>
		/// <br/>
		/// <br/>
		/// Client applications are expected to know what they are doing when<br/>
		/// invoking this function.  Most drivers simply do not implement file or<br/>
		/// stream attachments.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Attach_Stream")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError AttachStream(this FTFace face, [NativeName(NativeNameType.Param, "parameters")] [NativeName(NativeNameType.Type, "FT_Open_Args const *")] FTOpenArgs* parameters)
		{
			FTError ret = FreeType.AttachStreamNative(face, parameters);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Attach_Stream<br/>
		/// <br/>
		/// :<br/>
		/// 'Attach' data to a face object.  Normally, this is used to read<br/>
		/// additional information for the face object.  For example, you can<br/>
		/// attach an AFM file that comes with a Type~1 font to get the kerning<br/>
		/// values and other metrics.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The target face object.<br/>
		/// <br/>
		/// :<br/>
		/// parameters ::<br/>
		/// A pointer to <br/>
		/// _Open_Args that must be filled by the caller.<br/>
		/// <br/>
		/// <br/>
		/// Client applications are expected to know what they are doing when<br/>
		/// invoking this function.  Most drivers simply do not implement file or<br/>
		/// stream attachments.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Attach_Stream")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError AttachStream(this FTFace face, [NativeName(NativeNameType.Param, "parameters")] [NativeName(NativeNameType.Type, "FT_Open_Args const *")] ref FTOpenArgs parameters)
		{
			fixed (FTOpenArgs* pparameters = &parameters)
			{
				FTError ret = FreeType.AttachStreamNative(face, (FTOpenArgs*)pparameters);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Reference_Face<br/>
		/// <br/>
		/// :<br/>
		/// A counter gets initialized to~1 at the time an <br/>
		/// _Face structure is<br/>
		/// created.  This function increments the counter.  <br/>
		/// _Done_Face then<br/>
		/// only destroys a face if the counter is~1, otherwise it simply<br/>
		/// decrements the counter.<br/>
		/// This function helps in managing life-cycles of structures that<br/>
		/// reference <br/>
		/// _Face objects.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a target face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Reference_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError ReferenceFace(this FTFace face)
		{
			FTError ret = FreeType.ReferenceFaceNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Done_Face<br/>
		/// <br/>
		/// :<br/>
		/// Discard a given face object, as well as all of its child slots and<br/>
		/// sizes.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a target face object.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Done_Face")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError DoneFace(this FTFace face)
		{
			FTError ret = FreeType.DoneFaceNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Select_Size<br/>
		/// <br/>
		/// :<br/>
		/// Select a bitmap strike.  To be more precise, this function sets the<br/>
		/// scaling factors of the active <br/>
		/// _Size object in a face so that<br/>
		/// bitmaps from this particular strike are taken by <br/>
		/// _Load_Glyph and<br/>
		/// friends.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a target face object.<br/>
		/// <br/>
		/// :<br/>
		/// strike_index ::<br/>
		/// The index of the bitmap strike in the `available_sizes` field of<br/>
		/// <br/>
		/// _FaceRec structure.<br/>
		/// <br/>
		/// <br/>
		/// For GX and OpenType variation fonts, a bitmap strike makes sense only<br/>
		/// if the default instance is active (that is, no glyph variation takes<br/>
		/// place); otherwise, FreeType simply ignores bitmap strikes.  The same<br/>
		/// is true for all named instances that are different from the default<br/>
		/// instance.<br/>
		/// Don't use this function if you are using the FreeType cache API.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Select_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SelectSize(this FTFace face, [NativeName(NativeNameType.Param, "strike_index")] [NativeName(NativeNameType.Type, "FT_Int")] int strikeIndex)
		{
			FTError ret = FreeType.SelectSizeNative(face, strikeIndex);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Request_Size<br/>
		/// <br/>
		/// :<br/>
		/// Resize the scale of the active <br/>
		/// _Size object in a face.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a target face object.<br/>
		/// <br/>
		/// :<br/>
		/// req ::<br/>
		/// A pointer to a <br/>
		/// _Size_RequestRec.<br/>
		/// <br/>
		/// <br/>
		/// The relation between the requested size and the resulting glyph size<br/>
		/// is dependent entirely on how the size is defined in the source face.<br/>
		/// The font designer chooses the final size of each glyph relative to<br/>
		/// this size.  For more information refer to<br/>
		/// 'https://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'.<br/>
		/// Contrary to <br/>
		/// _Set_Char_Size, this function doesn't have special code<br/>
		/// to normalize zero-valued widths, heights, or resolutions, which are<br/>
		/// treated as <br/>
		/// _LOAD_NO_SCALE.<br/>
		/// Don't use this function if you are using the FreeType cache API.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Request_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError RequestSize(this FTFace face, [NativeName(NativeNameType.Param, "req")] [NativeName(NativeNameType.Type, "FT_Size_Request")] FTSizeRequest req)
		{
			FTError ret = FreeType.RequestSizeNative(face, req);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Char_Size<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Request_Size to request the nominal size (in points).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a target face object.<br/>
		/// <br/>
		/// :<br/>
		/// char_width ::<br/>
		/// The nominal width, in 26.6 fractional points.<br/>
		/// char_height ::<br/>
		/// The nominal height, in 26.6 fractional points.<br/>
		/// horz_resolution ::<br/>
		/// The horizontal resolution in dpi.<br/>
		/// vert_resolution ::<br/>
		/// The vertical resolution in dpi.<br/>
		/// <br/>
		/// <br/>
		/// If either the character width or height is zero, it is set equal to<br/>
		/// the other value.<br/>
		/// If either the horizontal or vertical resolution is zero, it is set<br/>
		/// equal to the other value.<br/>
		/// A character width or height smaller than 1pt is set to 1pt; if both<br/>
		/// resolution values are zero, they are set to 72dpi.<br/>
		/// Don't use this function if you are using the FreeType cache API.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Char_Size")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SetCharSize(this FTFace face, [NativeName(NativeNameType.Param, "char_width")] [NativeName(NativeNameType.Type, "FT_F26Dot6")] int charWidth, [NativeName(NativeNameType.Param, "char_height")] [NativeName(NativeNameType.Type, "FT_F26Dot6")] int charHeight, [NativeName(NativeNameType.Param, "horz_resolution")] [NativeName(NativeNameType.Type, "FT_UInt")] uint horzResolution, [NativeName(NativeNameType.Param, "vert_resolution")] [NativeName(NativeNameType.Type, "FT_UInt")] uint vertResolution)
		{
			FTError ret = FreeType.SetCharSizeNative(face, charWidth, charHeight, horzResolution, vertResolution);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Pixel_Sizes<br/>
		/// <br/>
		/// :<br/>
		/// Call <br/>
		/// _Request_Size to request the nominal size (in pixels).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the target face object.<br/>
		/// <br/>
		/// :<br/>
		/// pixel_width ::<br/>
		/// The nominal width, in pixels.<br/>
		/// pixel_height ::<br/>
		/// The nominal height, in pixels.<br/>
		/// <br/>
		/// <br/>
		/// Don't use this function if you are using the FreeType cache API.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Pixel_Sizes")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SetPixelSizes(this FTFace face, [NativeName(NativeNameType.Param, "pixel_width")] [NativeName(NativeNameType.Type, "FT_UInt")] uint pixelWidth, [NativeName(NativeNameType.Param, "pixel_height")] [NativeName(NativeNameType.Type, "FT_UInt")] uint pixelHeight)
		{
			FTError ret = FreeType.SetPixelSizesNative(face, pixelWidth, pixelHeight);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// Load a glyph into the glyph slot of a face object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the target face object where the glyph is loaded.<br/>
		/// <br/>
		/// :<br/>
		/// glyph_index ::<br/>
		/// The index of the glyph in the font file.  For CID-keyed fonts<br/>
		/// (either in PS or in CFF format) this argument specifies the CID<br/>
		/// value.<br/>
		/// load_flags ::<br/>
		/// A flag indicating what to load for this glyph.  The <br/>
		/// _LOAD_XXX<br/>
		/// flags can be used to control the glyph loading process (e.g.,<br/>
		/// whether the outline should be scaled, whether to load bitmaps or<br/>
		/// not, whether to hint the outline, etc).<br/>
		/// <br/>
		/// <br/>
		/// For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument` is returned<br/>
		/// for invalid CID values (that is, for CID values that don't have a<br/>
		/// corresponding glyph in the font).  See the discussion of the<br/>
		/// <br/>
		/// _FACE_FLAG_CID_KEYED flag for more details.<br/>
		/// If you receive `FT_Err_Glyph_Too_Big`, try getting the glyph outline<br/>
		/// at EM size, then scale it manually and fill it as a graphics<br/>
		/// operation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError LoadGlyph(this FTFace face, [NativeName(NativeNameType.Param, "glyph_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint glyphIndex, [NativeName(NativeNameType.Param, "load_flags")] [NativeName(NativeNameType.Type, "FT_Int32")] int loadFlags)
		{
			FTError ret = FreeType.LoadGlyphNative(face, glyphIndex, loadFlags);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Char<br/>
		/// <br/>
		/// :<br/>
		/// Load a glyph into the glyph slot of a face object, accessed by its<br/>
		/// character code.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a target face object where the glyph is loaded.<br/>
		/// <br/>
		/// :<br/>
		/// char_code ::<br/>
		/// The glyph's character code, according to the current charmap used in<br/>
		/// the face.<br/>
		/// load_flags ::<br/>
		/// A flag indicating what to load for this glyph.  The <br/>
		/// _LOAD_XXX<br/>
		/// constants can be used to control the glyph loading process (e.g.,<br/>
		/// whether the outline should be scaled, whether to load bitmaps or<br/>
		/// not, whether to hint the outline, etc).<br/>
		/// <br/>
		/// <br/>
		/// Many fonts contain glyphs that can't be loaded by this function since<br/>
		/// its glyph indices are not listed in any of the font's charmaps.<br/>
		/// If no active cmap is set up (i.e., `face->charmap` is zero), the call<br/>
		/// to <br/>
		/// _Get_Char_Index is omitted, and the function behaves identically<br/>
		/// to <br/>
		/// _Load_Glyph.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Char")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError LoadChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "load_flags")] [NativeName(NativeNameType.Type, "FT_Int32")] int loadFlags)
		{
			FTError ret = FreeType.LoadCharNative(face, charCode, loadFlags);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Set the transformation that is applied to glyph images when they are<br/>
		/// loaded into a glyph slot through <br/>
		/// _Load_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>
		/// identity matrix.<br/>
		/// delta ::<br/>
		/// A pointer to the translation vector.  Use `NULL` for the null<br/>
		/// vector.<br/>
		/// <br/>
		/// The transformation is only applied to scalable image formats after the<br/>
		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>
		/// transformation and is performed on the character size given in the<br/>
		/// last call to <br/>
		/// _Set_Char_Size or <br/>
		/// _Set_Pixel_Sizes.<br/>
		/// Note that this also transforms the `face.glyph.advance` field, but<br/>
		/// **not** the values in `face.glyph.metrics`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* delta)
		{
			FreeType.SetTransformNative(face, matrix, delta);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Set the transformation that is applied to glyph images when they are<br/>
		/// loaded into a glyph slot through <br/>
		/// _Load_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>
		/// identity matrix.<br/>
		/// delta ::<br/>
		/// A pointer to the translation vector.  Use `NULL` for the null<br/>
		/// vector.<br/>
		/// <br/>
		/// The transformation is only applied to scalable image formats after the<br/>
		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>
		/// transformation and is performed on the character size given in the<br/>
		/// last call to <br/>
		/// _Set_Char_Size or <br/>
		/// _Set_Pixel_Sizes.<br/>
		/// Note that this also transforms the `face.glyph.advance` field, but<br/>
		/// **not** the values in `face.glyph.metrics`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FreeType.SetTransformNative(face, (FTMatrix*)pmatrix, delta);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Set the transformation that is applied to glyph images when they are<br/>
		/// loaded into a glyph slot through <br/>
		/// _Load_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>
		/// identity matrix.<br/>
		/// delta ::<br/>
		/// A pointer to the translation vector.  Use `NULL` for the null<br/>
		/// vector.<br/>
		/// <br/>
		/// The transformation is only applied to scalable image formats after the<br/>
		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>
		/// transformation and is performed on the character size given in the<br/>
		/// last call to <br/>
		/// _Set_Char_Size or <br/>
		/// _Set_Pixel_Sizes.<br/>
		/// Note that this also transforms the `face.glyph.advance` field, but<br/>
		/// **not** the values in `face.glyph.metrics`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FreeType.SetTransformNative(face, matrix, (FTVector*)pdelta);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Set the transformation that is applied to glyph images when they are<br/>
		/// loaded into a glyph slot through <br/>
		/// _Load_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation's 2x2 matrix.  Use `NULL` for the<br/>
		/// identity matrix.<br/>
		/// delta ::<br/>
		/// A pointer to the translation vector.  Use `NULL` for the null<br/>
		/// vector.<br/>
		/// <br/>
		/// The transformation is only applied to scalable image formats after the<br/>
		/// glyph has been loaded.  It means that hinting is unaltered by the<br/>
		/// transformation and is performed on the character size given in the<br/>
		/// last call to <br/>
		/// _Set_Char_Size or <br/>
		/// _Set_Pixel_Sizes.<br/>
		/// Note that this also transforms the `face.glyph.advance` field, but<br/>
		/// **not** the values in `face.glyph.metrics`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FreeType.SetTransformNative(face, (FTMatrix*)pmatrix, (FTVector*)pdelta);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Return the transformation that is applied to glyph images when they<br/>
		/// are loaded into a glyph slot through <br/>
		/// _Load_Glyph.  See<br/>
		/// <br/>
		/// _Set_Transform for more details.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>
		/// are not interested in the value.<br/>
		/// delta ::<br/>
		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>
		/// interested in the value.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* delta)
		{
			FreeType.GetTransformNative(face, matrix, delta);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Return the transformation that is applied to glyph images when they<br/>
		/// are loaded into a glyph slot through <br/>
		/// _Load_Glyph.  See<br/>
		/// <br/>
		/// _Set_Transform for more details.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>
		/// are not interested in the value.<br/>
		/// delta ::<br/>
		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>
		/// interested in the value.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FreeType.GetTransformNative(face, (FTMatrix*)pmatrix, delta);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Return the transformation that is applied to glyph images when they<br/>
		/// are loaded into a glyph slot through <br/>
		/// _Load_Glyph.  See<br/>
		/// <br/>
		/// _Set_Transform for more details.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>
		/// are not interested in the value.<br/>
		/// delta ::<br/>
		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>
		/// interested in the value.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FreeType.GetTransformNative(face, matrix, (FTVector*)pdelta);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Return the transformation that is applied to glyph images when they<br/>
		/// are loaded into a glyph slot through <br/>
		/// _Load_Glyph.  See<br/>
		/// <br/>
		/// _Set_Transform for more details.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a transformation's 2x2 matrix.  Set this to NULL if you<br/>
		/// are not interested in the value.<br/>
		/// delta ::<br/>
		/// A pointer to a translation vector.  Set this to NULL if you are not<br/>
		/// interested in the value.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GetTransform(this FTFace face, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FreeType.GetTransformNative(face, (FTMatrix*)pmatrix, (FTVector*)pdelta);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Kerning<br/>
		/// <br/>
		/// :<br/>
		/// Return the kerning vector between two glyphs of the same face.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a source face object.<br/>
		/// left_glyph ::<br/>
		/// The index of the left glyph in the kern pair.<br/>
		/// right_glyph ::<br/>
		/// The index of the right glyph in the kern pair.<br/>
		/// kern_mode ::<br/>
		/// See <br/>
		/// _Kerning_Mode for more information.  Determines the scale and<br/>
		/// dimension of the returned kerning vector.<br/>
		/// <br/>
		/// :<br/>
		/// akerning ::<br/>
		/// The kerning vector.  This is either in font units, fractional pixels<br/>
		/// (26.6 format), or pixels for scalable formats, and in pixels for<br/>
		/// fixed-sizes formats.<br/>
		/// <br/>
		/// <br/>
		/// Note that, for TrueType fonts only, this can extract data from both<br/>
		/// the 'kern' table and the basic, pair-wise kerning feature from the<br/>
		/// GPOS table (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though<br/>
		/// FreeType does not support the more advanced GPOS layout features; use<br/>
		/// a library like HarfBuzz for those instead.  If a font has both a<br/>
		/// 'kern' table and kern features of a GPOS table, the 'kern' table will<br/>
		/// be used.<br/>
		/// Also note for right-to-left scripts, the functionality may differ for<br/>
		/// fonts with GPOS tables vs. 'kern' tables.  For GPOS, right-to-left<br/>
		/// fonts typically use both a placement offset and an advance for pair<br/>
		/// positioning, which this API does not support, so it would output<br/>
		/// kerning values of zero; though if the right-to-left font used only<br/>
		/// advances in GPOS pair positioning, then this API could output kerning<br/>
		/// values for it, but it would use `left_glyph` to mean the first glyph<br/>
		/// for that case.  Whereas 'kern' tables are always advance-only and<br/>
		/// always store the left glyph first.<br/>
		/// Use <br/>
		/// _HAS_KERNING to find out whether a font has data that can be<br/>
		/// extracted with `FT_Get_Kerning`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetKerning(this FTFace face, [NativeName(NativeNameType.Param, "left_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint leftGlyph, [NativeName(NativeNameType.Param, "right_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint rightGlyph, [NativeName(NativeNameType.Param, "kern_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint kernMode, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* akerning)
		{
			FTError ret = FreeType.GetKerningNative(face, leftGlyph, rightGlyph, kernMode, akerning);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Kerning<br/>
		/// <br/>
		/// :<br/>
		/// Return the kerning vector between two glyphs of the same face.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a source face object.<br/>
		/// left_glyph ::<br/>
		/// The index of the left glyph in the kern pair.<br/>
		/// right_glyph ::<br/>
		/// The index of the right glyph in the kern pair.<br/>
		/// kern_mode ::<br/>
		/// See <br/>
		/// _Kerning_Mode for more information.  Determines the scale and<br/>
		/// dimension of the returned kerning vector.<br/>
		/// <br/>
		/// :<br/>
		/// akerning ::<br/>
		/// The kerning vector.  This is either in font units, fractional pixels<br/>
		/// (26.6 format), or pixels for scalable formats, and in pixels for<br/>
		/// fixed-sizes formats.<br/>
		/// <br/>
		/// <br/>
		/// Note that, for TrueType fonts only, this can extract data from both<br/>
		/// the 'kern' table and the basic, pair-wise kerning feature from the<br/>
		/// GPOS table (with `TT_CONFIG_OPTION_GPOS_KERNING` enabled), though<br/>
		/// FreeType does not support the more advanced GPOS layout features; use<br/>
		/// a library like HarfBuzz for those instead.  If a font has both a<br/>
		/// 'kern' table and kern features of a GPOS table, the 'kern' table will<br/>
		/// be used.<br/>
		/// Also note for right-to-left scripts, the functionality may differ for<br/>
		/// fonts with GPOS tables vs. 'kern' tables.  For GPOS, right-to-left<br/>
		/// fonts typically use both a placement offset and an advance for pair<br/>
		/// positioning, which this API does not support, so it would output<br/>
		/// kerning values of zero; though if the right-to-left font used only<br/>
		/// advances in GPOS pair positioning, then this API could output kerning<br/>
		/// values for it, but it would use `left_glyph` to mean the first glyph<br/>
		/// for that case.  Whereas 'kern' tables are always advance-only and<br/>
		/// always store the left glyph first.<br/>
		/// Use <br/>
		/// _HAS_KERNING to find out whether a font has data that can be<br/>
		/// extracted with `FT_Get_Kerning`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetKerning(this FTFace face, [NativeName(NativeNameType.Param, "left_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint leftGlyph, [NativeName(NativeNameType.Param, "right_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint rightGlyph, [NativeName(NativeNameType.Param, "kern_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint kernMode, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector akerning)
		{
			fixed (FTVector* pakerning = &akerning)
			{
				FTError ret = FreeType.GetKerningNative(face, leftGlyph, rightGlyph, kernMode, (FTVector*)pakerning);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Track_Kerning<br/>
		/// <br/>
		/// :<br/>
		/// Return the track kerning for a given face object at a given size.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a source face object.<br/>
		/// point_size ::<br/>
		/// The point size in 16.16 fractional points.<br/>
		/// degree ::<br/>
		/// The degree of tightness.  Increasingly negative values represent<br/>
		/// tighter track kerning, while increasingly positive values represent<br/>
		/// looser track kerning.  Value zero means no track kerning.<br/>
		/// <br/>
		/// :<br/>
		/// akerning ::<br/>
		/// The kerning in 16.16 fractional points, to be uniformly applied<br/>
		/// between all glyphs.<br/>
		/// <br/>
		/// <br/>
		/// Only very few AFM files come with track kerning data; please refer to<br/>
		/// Adobe's AFM specification for more details.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Track_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetTrackKerning(this FTFace face, [NativeName(NativeNameType.Param, "point_size")] [NativeName(NativeNameType.Type, "FT_Fixed")] int pointSize, [NativeName(NativeNameType.Param, "degree")] [NativeName(NativeNameType.Type, "FT_Int")] int degree, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Fixed *")] int* akerning)
		{
			FTError ret = FreeType.GetTrackKerningNative(face, pointSize, degree, akerning);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Track_Kerning<br/>
		/// <br/>
		/// :<br/>
		/// Return the track kerning for a given face object at a given size.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a source face object.<br/>
		/// point_size ::<br/>
		/// The point size in 16.16 fractional points.<br/>
		/// degree ::<br/>
		/// The degree of tightness.  Increasingly negative values represent<br/>
		/// tighter track kerning, while increasingly positive values represent<br/>
		/// looser track kerning.  Value zero means no track kerning.<br/>
		/// <br/>
		/// :<br/>
		/// akerning ::<br/>
		/// The kerning in 16.16 fractional points, to be uniformly applied<br/>
		/// between all glyphs.<br/>
		/// <br/>
		/// <br/>
		/// Only very few AFM files come with track kerning data; please refer to<br/>
		/// Adobe's AFM specification for more details.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Track_Kerning")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetTrackKerning(this FTFace face, [NativeName(NativeNameType.Param, "point_size")] [NativeName(NativeNameType.Type, "FT_Fixed")] int pointSize, [NativeName(NativeNameType.Param, "degree")] [NativeName(NativeNameType.Type, "FT_Int")] int degree, [NativeName(NativeNameType.Param, "akerning")] [NativeName(NativeNameType.Type, "FT_Fixed *")] ref int akerning)
		{
			fixed (int* pakerning = &akerning)
			{
				FTError ret = FreeType.GetTrackKerningNative(face, pointSize, degree, (int*)pakerning);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Select_Charmap<br/>
		/// <br/>
		/// :<br/>
		/// Select a given charmap by its encoding tag (as listed in<br/>
		/// `freetype.h`).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// encoding ::<br/>
		/// A handle to the selected encoding.<br/>
		/// <br/>
		/// <br/>
		/// Because many fonts contain more than a single cmap for Unicode<br/>
		/// encoding, this function has some special code to select the one that<br/>
		/// covers Unicode best ('best' in the sense that a UCS-4 cmap is<br/>
		/// preferred to a UCS-2 cmap).  It is thus preferable to <br/>
		/// _Set_Charmap<br/>
		/// in this case.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Select_Charmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SelectCharmap(this FTFace face, [NativeName(NativeNameType.Param, "encoding")] [NativeName(NativeNameType.Type, "FT_Encoding")] FTEncoding encoding)
		{
			FTError ret = FreeType.SelectCharmapNative(face, encoding);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Set_Charmap<br/>
		/// <br/>
		/// :<br/>
		/// Select a given charmap for character code to glyph index mapping.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// A handle to the selected charmap.<br/>
		/// <br/>
		/// <br/>
		/// It also fails if an OpenType type~14 charmap is selected (which<br/>
		/// doesn't map character codes to glyph indices at all).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Set_Charmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SetCharmap(this FTFace face, [NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			FTError ret = FreeType.SetCharmapNative(face, charmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Char_Index<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given character code.  This function uses<br/>
		/// the currently selected charmap to do the mapping.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character code.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Char_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetCharIndex(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint ret = FreeType.GetCharIndexNative(face, charcode);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_First_Char<br/>
		/// <br/>
		/// :<br/>
		/// Return the first character code in the current charmap of a given<br/>
		/// face, together with its corresponding glyph index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// agindex ::<br/>
		/// Glyph index of first character code.  0~if charmap is empty.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  charcode;<br/>
		/// FT_UInt   gindex;<br/>
		/// charcode = FT_Get_First_Char( face, <br/>
		/// &gindex<br/>
		/// );<br/>
		/// while ( gindex != 0 )<br/>
		/// {<br/>
		/// ... do something with (charcode,gindex) pair ...<br/>
		/// charcode = FT_Get_Next_Char( face, charcode, <br/>
		/// &gindex<br/>
		/// );<br/>
		/// }<br/>
		/// ```<br/>
		/// Be aware that character codes can have values up to 0xFFFFFFFF; this<br/>
		/// might happen for non-Unicode or malformed cmaps.  However, even with<br/>
		/// regular Unicode encoding, so-called 'last resort fonts' (using SFNT<br/>
		/// cmap format 13, see function <br/>
		/// _Get_CMap_Format) normally have<br/>
		/// entries for all Unicode characters up to 0x1FFFFF, which can cause *a<br/>
		/// lot* of iterations.<br/>
		/// Note that `*agindex` is set to~0 if the charmap is empty.  The result<br/>
		/// itself can be~0 in two cases: if the charmap is empty or if the<br/>
		/// value~0 is the first valid character code.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_First_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetFirstChar(this FTFace face, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* agindex)
		{
			uint ret = FreeType.GetFirstCharNative(face, agindex);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_First_Char<br/>
		/// <br/>
		/// :<br/>
		/// Return the first character code in the current charmap of a given<br/>
		/// face, together with its corresponding glyph index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// :<br/>
		/// agindex ::<br/>
		/// Glyph index of first character code.  0~if charmap is empty.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  charcode;<br/>
		/// FT_UInt   gindex;<br/>
		/// charcode = FT_Get_First_Char( face, <br/>
		/// &gindex<br/>
		/// );<br/>
		/// while ( gindex != 0 )<br/>
		/// {<br/>
		/// ... do something with (charcode,gindex) pair ...<br/>
		/// charcode = FT_Get_Next_Char( face, charcode, <br/>
		/// &gindex<br/>
		/// );<br/>
		/// }<br/>
		/// ```<br/>
		/// Be aware that character codes can have values up to 0xFFFFFFFF; this<br/>
		/// might happen for non-Unicode or malformed cmaps.  However, even with<br/>
		/// regular Unicode encoding, so-called 'last resort fonts' (using SFNT<br/>
		/// cmap format 13, see function <br/>
		/// _Get_CMap_Format) normally have<br/>
		/// entries for all Unicode characters up to 0x1FFFFF, which can cause *a<br/>
		/// lot* of iterations.<br/>
		/// Note that `*agindex` is set to~0 if the charmap is empty.  The result<br/>
		/// itself can be~0 in two cases: if the charmap is empty or if the<br/>
		/// value~0 is the first valid character code.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_First_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetFirstChar(this FTFace face, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint agindex)
		{
			fixed (uint* pagindex = &agindex)
			{
				uint ret = FreeType.GetFirstCharNative(face, (uint*)pagindex);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Next_Char<br/>
		/// <br/>
		/// :<br/>
		/// Return the next character code in the current charmap of a given face<br/>
		/// following the value `char_code`, as well as the corresponding glyph<br/>
		/// index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// char_code ::<br/>
		/// The starting character code.<br/>
		/// <br/>
		/// :<br/>
		/// agindex ::<br/>
		/// Glyph index of next character code.  0~if charmap is empty.<br/>
		/// <br/>
		/// <br/>
		/// Note that `*agindex` is set to~0 when there are no more codes in the<br/>
		/// charmap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Next_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetNextChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* agindex)
		{
			uint ret = FreeType.GetNextCharNative(face, charCode, agindex);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Next_Char<br/>
		/// <br/>
		/// :<br/>
		/// Return the next character code in the current charmap of a given face<br/>
		/// following the value `char_code`, as well as the corresponding glyph<br/>
		/// index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// char_code ::<br/>
		/// The starting character code.<br/>
		/// <br/>
		/// :<br/>
		/// agindex ::<br/>
		/// Glyph index of next character code.  0~if charmap is empty.<br/>
		/// <br/>
		/// <br/>
		/// Note that `*agindex` is set to~0 when there are no more codes in the<br/>
		/// charmap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Next_Char")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetNextChar(this FTFace face, [NativeName(NativeNameType.Param, "char_code")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charCode, [NativeName(NativeNameType.Param, "agindex")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint agindex)
		{
			fixed (uint* pagindex = &agindex)
			{
				uint ret = FreeType.GetNextCharNative(face, charCode, (uint*)pagindex);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_Properties<br/>
		/// <br/>
		/// :<br/>
		/// Set or override certain (library or module-wide) properties on a<br/>
		/// face-by-face basis.  Useful for finer-grained control and avoiding<br/>
		/// locks on shared structures (threads can modify their own faces as they<br/>
		/// see fit).<br/>
		/// Contrary to <br/>
		/// _Property_Set, this function uses <br/>
		/// _Parameter so that<br/>
		/// you can pass multiple properties to the target face in one call.  Note<br/>
		/// that only a subset of the available properties can be controlled.<br/>
		/// * <br/>
		/// _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the<br/>
		/// property `no-stem-darkening` provided by the 'autofit', 'cff',<br/>
		/// 'type1', and 't1cid' modules; see <br/>
		/// -stem-darkening).<br/>
		/// * <br/>
		/// _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding<br/>
		/// to function <br/>
		/// _Library_SetLcdFilterWeights).<br/>
		/// * <br/>
		/// _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID<br/>
		/// 'random' operator, corresponding to the `random-seed` property<br/>
		/// provided by the 'cff', 'type1', and 't1cid' modules; see<br/>
		/// <br/>
		/// -seed).<br/>
		/// Pass `NULL` as `data` in <br/>
		/// _Parameter for a given tag to reset the<br/>
		/// option and use the library or module default again.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// num_properties ::<br/>
		/// The number of properties that follow.<br/>
		/// properties ::<br/>
		/// A handle to an <br/>
		/// _Parameter array with `num_properties` elements.<br/>
		/// <br/>
		/// <br/>
		/// Here is an example that sets three properties.  You must define<br/>
		/// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples<br/>
		/// work.<br/>
		/// ```<br/>
		/// FT_Parameter         property1;<br/>
		/// FT_Bool              darken_stems = 1;<br/>
		/// FT_Parameter         property2;<br/>
		/// FT_LcdFiveTapFilter  custom_weight =<br/>
		/// { 0x11, 0x44, 0x56, 0x44, 0x11 };<br/>
		/// FT_Parameter         property3;<br/>
		/// FT_Int32             random_seed = 314159265;<br/>
		/// FT_Parameter         properties[3] = { property1,<br/>
		/// property2,<br/>
		/// property3 };<br/>
		/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;<br/>
		/// property1.data = <br/>
		/// &darken<br/>
		/// _stems;<br/>
		/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>
		/// property2.data = custom_weight;<br/>
		/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;<br/>
		/// property3.data = <br/>
		/// &random<br/>
		/// _seed;<br/>
		/// FT_Face_Properties( face, 3, properties );<br/>
		/// ```<br/>
		/// The next example resets a single property to its default value.<br/>
		/// ```<br/>
		/// FT_Parameter  property;<br/>
		/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>
		/// property.data = NULL;<br/>
		/// FT_Face_Properties( face, 1, <br/>
		/// &property<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_Properties")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError Properties(this FTFace face, [NativeName(NativeNameType.Param, "num_properties")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numProperties, [NativeName(NativeNameType.Param, "properties")] [NativeName(NativeNameType.Type, "FT_Parameter *")] FTParameter* properties)
		{
			FTError ret = FreeType.FacePropertiesNative(face, numProperties, properties);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_Properties<br/>
		/// <br/>
		/// :<br/>
		/// Set or override certain (library or module-wide) properties on a<br/>
		/// face-by-face basis.  Useful for finer-grained control and avoiding<br/>
		/// locks on shared structures (threads can modify their own faces as they<br/>
		/// see fit).<br/>
		/// Contrary to <br/>
		/// _Property_Set, this function uses <br/>
		/// _Parameter so that<br/>
		/// you can pass multiple properties to the target face in one call.  Note<br/>
		/// that only a subset of the available properties can be controlled.<br/>
		/// * <br/>
		/// _PARAM_TAG_STEM_DARKENING (stem darkening, corresponding to the<br/>
		/// property `no-stem-darkening` provided by the 'autofit', 'cff',<br/>
		/// 'type1', and 't1cid' modules; see <br/>
		/// -stem-darkening).<br/>
		/// * <br/>
		/// _PARAM_TAG_LCD_FILTER_WEIGHTS (LCD filter weights, corresponding<br/>
		/// to function <br/>
		/// _Library_SetLcdFilterWeights).<br/>
		/// * <br/>
		/// _PARAM_TAG_RANDOM_SEED (seed value for the CFF, Type~1, and CID<br/>
		/// 'random' operator, corresponding to the `random-seed` property<br/>
		/// provided by the 'cff', 'type1', and 't1cid' modules; see<br/>
		/// <br/>
		/// -seed).<br/>
		/// Pass `NULL` as `data` in <br/>
		/// _Parameter for a given tag to reset the<br/>
		/// option and use the library or module default again.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// num_properties ::<br/>
		/// The number of properties that follow.<br/>
		/// properties ::<br/>
		/// A handle to an <br/>
		/// _Parameter array with `num_properties` elements.<br/>
		/// <br/>
		/// <br/>
		/// Here is an example that sets three properties.  You must define<br/>
		/// `FT_CONFIG_OPTION_SUBPIXEL_RENDERING` to make the LCD filter examples<br/>
		/// work.<br/>
		/// ```<br/>
		/// FT_Parameter         property1;<br/>
		/// FT_Bool              darken_stems = 1;<br/>
		/// FT_Parameter         property2;<br/>
		/// FT_LcdFiveTapFilter  custom_weight =<br/>
		/// { 0x11, 0x44, 0x56, 0x44, 0x11 };<br/>
		/// FT_Parameter         property3;<br/>
		/// FT_Int32             random_seed = 314159265;<br/>
		/// FT_Parameter         properties[3] = { property1,<br/>
		/// property2,<br/>
		/// property3 };<br/>
		/// property1.tag  = FT_PARAM_TAG_STEM_DARKENING;<br/>
		/// property1.data = <br/>
		/// &darken<br/>
		/// _stems;<br/>
		/// property2.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>
		/// property2.data = custom_weight;<br/>
		/// property3.tag  = FT_PARAM_TAG_RANDOM_SEED;<br/>
		/// property3.data = <br/>
		/// &random<br/>
		/// _seed;<br/>
		/// FT_Face_Properties( face, 3, properties );<br/>
		/// ```<br/>
		/// The next example resets a single property to its default value.<br/>
		/// ```<br/>
		/// FT_Parameter  property;<br/>
		/// property.tag  = FT_PARAM_TAG_LCD_FILTER_WEIGHTS;<br/>
		/// property.data = NULL;<br/>
		/// FT_Face_Properties( face, 1, <br/>
		/// &property<br/>
		/// );<br/>
		/// ```<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_Properties")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError Properties(this FTFace face, [NativeName(NativeNameType.Param, "num_properties")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numProperties, [NativeName(NativeNameType.Param, "properties")] [NativeName(NativeNameType.Type, "FT_Parameter *")] ref FTParameter properties)
		{
			fixed (FTParameter* pproperties = &properties)
			{
				FTError ret = FreeType.FacePropertiesNative(face, numProperties, (FTParameter*)pproperties);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Name_Index<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given glyph name.  This only works<br/>
		/// for those faces where <br/>
		/// _HAS_GLYPH_NAMES returns true.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// glyph_name ::<br/>
		/// The glyph name.<br/>
		/// <br/>
		/// <br/>
		/// This function has limited capabilities if the config macro<br/>
		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>
		/// It then works only for fonts that actually embed glyph names (which<br/>
		/// many recent OpenType fonts do not).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "FT_String const *")] byte* glyphName)
		{
			uint ret = FreeType.GetNameIndexNative(face, glyphName);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Name_Index<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given glyph name.  This only works<br/>
		/// for those faces where <br/>
		/// _HAS_GLYPH_NAMES returns true.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// glyph_name ::<br/>
		/// The glyph name.<br/>
		/// <br/>
		/// <br/>
		/// This function has limited capabilities if the config macro<br/>
		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>
		/// It then works only for fonts that actually embed glyph names (which<br/>
		/// many recent OpenType fonts do not).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "FT_String const *")] ref byte glyphName)
		{
			fixed (byte* pglyphName = &glyphName)
			{
				uint ret = FreeType.GetNameIndexNative(face, (byte*)pglyphName);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Name_Index<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given glyph name.  This only works<br/>
		/// for those faces where <br/>
		/// _HAS_GLYPH_NAMES returns true.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// glyph_name ::<br/>
		/// The glyph name.<br/>
		/// <br/>
		/// <br/>
		/// This function has limited capabilities if the config macro<br/>
		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>
		/// It then works only for fonts that actually embed glyph names (which<br/>
		/// many recent OpenType fonts do not).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "FT_String const *")] ReadOnlySpan<byte> glyphName)
		{
			fixed (byte* pglyphName = glyphName)
			{
				uint ret = FreeType.GetNameIndexNative(face, (byte*)pglyphName);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Name_Index<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given glyph name.  This only works<br/>
		/// for those faces where <br/>
		/// _HAS_GLYPH_NAMES returns true.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// glyph_name ::<br/>
		/// The glyph name.<br/>
		/// <br/>
		/// <br/>
		/// This function has limited capabilities if the config macro<br/>
		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>
		/// It then works only for fonts that actually embed glyph names (which<br/>
		/// many recent OpenType fonts do not).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Name_Index")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetNameIndex(this FTFace face, [NativeName(NativeNameType.Param, "glyph_name")] [NativeName(NativeNameType.Type, "FT_String const *")] string glyphName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (glyphName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(glyphName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(glyphName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = FreeType.GetNameIndexNative(face, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Glyph_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the ASCII name of a given glyph in a face.  This only works<br/>
		/// for those faces where <br/>
		/// _HAS_GLYPH_NAMES returns true.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to a source face object.<br/>
		/// glyph_index ::<br/>
		/// The glyph index.<br/>
		/// buffer_max ::<br/>
		/// The maximum number of bytes available in the buffer.<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// A pointer to a target buffer where the name is copied to.<br/>
		/// <br/>
		/// <br/>
		/// The glyph name is truncated to fit within the buffer if it is too<br/>
		/// long.  The returned string is always zero-terminated.<br/>
		/// Be aware that FreeType reorders glyph indices internally so that glyph<br/>
		/// index~0 always corresponds to the 'missing glyph' (called '.notdef').<br/>
		/// This function has limited capabilities if the config macro<br/>
		/// `FT_CONFIG_OPTION_POSTSCRIPT_NAMES` is not defined in `ftoption.h`:<br/>
		/// It then works only for fonts that actually embed glyph names (which<br/>
		/// many recent OpenType fonts do not).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Glyph_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetGlyphName(this FTFace face, [NativeName(NativeNameType.Param, "glyph_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint glyphIndex, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Pointer")] FTPointer buffer, [NativeName(NativeNameType.Param, "buffer_max")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bufferMax)
		{
			FTError ret = FreeType.GetGlyphNameNative(face, glyphIndex, buffer, bufferMax);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Postscript_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the ASCII PostScript name of a given face, if available.<br/>
		/// This only works with PostScript, TrueType, and OpenType fonts.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// For variation fonts, this string changes if you select a different<br/>
		/// instance, and you have to call `FT_Get_PostScript_Name` again to<br/>
		/// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating<br/>
		/// PostScript Names for Fonts Using OpenType Font Variations'.<br/>
		/// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html<br/>
		/// [Since 2.9] Special PostScript names for named instances are only<br/>
		/// returned if the named instance is set with <br/>
		/// _Set_Named_Instance (and<br/>
		/// the font has corresponding entries in its 'fvar' table or is the<br/>
		/// default named instance).  If <br/>
		/// _IS_VARIATION returns true, the<br/>
		/// algorithmically derived PostScript name is provided, not looking up<br/>
		/// special entries for named instances.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Postscript_Name")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static byte* GetPostscriptName(this FTFace face)
		{
			byte* ret = FreeType.GetPostscriptNameNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Postscript_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the ASCII PostScript name of a given face, if available.<br/>
		/// This only works with PostScript, TrueType, and OpenType fonts.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// For variation fonts, this string changes if you select a different<br/>
		/// instance, and you have to call `FT_Get_PostScript_Name` again to<br/>
		/// retrieve it.  FreeType follows Adobe TechNote #5902, 'Generating<br/>
		/// PostScript Names for Fonts Using OpenType Font Variations'.<br/>
		/// https://download.macromedia.com/pub/developer/opentype/tech-notes/5902.AdobePSNameGeneration.html<br/>
		/// [Since 2.9] Special PostScript names for named instances are only<br/>
		/// returned if the named instance is set with <br/>
		/// _Set_Named_Instance (and<br/>
		/// the font has corresponding entries in its 'fvar' table or is the<br/>
		/// default named instance).  If <br/>
		/// _IS_VARIATION returns true, the<br/>
		/// algorithmically derived PostScript name is provided, not looking up<br/>
		/// special entries for named instances.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Postscript_Name")]
		[return: NativeName(NativeNameType.Type, "char const *")]
		public static string GetPostscriptNameS(this FTFace face)
		{
			string ret = Utils.DecodeStringUTF8(FreeType.GetPostscriptNameNative(face));
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_FSType_Flags<br/>
		/// <br/>
		/// :<br/>
		/// Return the `fsType` flags for a font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		public static ushort GetFsTypeFlags(this FTFace face)
		{
			ushort ret = FreeType.GetFSTypeFlagsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIndex<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given character code as modified by the<br/>
		/// variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character code point in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode code point of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// This function is only meaningful if<br/>
		/// a) the font has a variation selector cmap sub table, and<br/>
		/// b) the current charmap has a Unicode encoding.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetCharVariantIndex(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint ret = FreeType.FaceGetCharVariantIndexNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIsDefault<br/>
		/// <br/>
		/// :<br/>
		/// Check whether this variation of this Unicode character is the one to<br/>
		/// be found in the charmap.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode codepoint of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int GetCharVariantIsDefault(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			int ret = FreeType.FaceGetCharVariantIsDefaultNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantSelectors<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found in<br/>
		/// the font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		public static uint* GetVariantSelectors(this FTFace face)
		{
			uint* ret = FreeType.FaceGetVariantSelectorsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantsOfChar<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found for<br/>
		/// the specified character code.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		public static uint* GetVariantsOfChar(this FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint* ret = FreeType.FaceGetVariantsOfCharNative(face, charcode);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharsOfVariant<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode character codes found for the<br/>
		/// specified variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// variantSelector ::<br/>
		/// The variation selector code point in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		public static uint* GetCharsOfVariant(this FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint* ret = FreeType.FaceGetCharsOfVariantNative(face, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_CheckTrueTypePatents<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte CheckTrueTypePatents(this FTFace face)
		{
			byte ret = FreeType.FaceCheckTrueTypePatentsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_SetUnpatentedHinting<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// value ::<br/>
		/// New boolean setting.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte SetUnpatentedHinting(this FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value)
		{
			byte ret = FreeType.FaceSetUnpatentedHintingNative(face, value);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Data_Get<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the face's color palette data.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// A pointer to an <br/>
		/// _Palette_Data structure.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteDataGet(this FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data *")] FTPaletteData* apalette)
		{
			FTError ret = FreeType.PaletteDataGetNative(face, apalette);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Data_Get<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the face's color palette data.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// A pointer to an <br/>
		/// _Palette_Data structure.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteDataGet(this FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data *")] ref FTPaletteData apalette)
		{
			fixed (FTPaletteData* papalette = &apalette)
			{
				FTError ret = FreeType.PaletteDataGetNative(face, (FTPaletteData*)papalette);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Select<br/>
		/// <br/>
		/// :<br/>
		/// This function has two purposes.<br/>
		/// (1) It activates a palette for rendering color glyphs, and<br/>
		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>
		/// function returns a read-write array, which means that a calling<br/>
		/// application can modify the palette entries on demand.<br/>
		/// A corollary of (2) is that calling the function, then modifying some<br/>
		/// values, then calling the function again with the same arguments resets<br/>
		/// all color entries to the original 'CPAL' values; all user modifications<br/>
		/// are lost.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// palette_index ::<br/>
		/// The palette index.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// An array of color entries for a palette with index `palette_index`,<br/>
		/// having `num_palette_entries` elements (as found in the<br/>
		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>
		/// array gets returned (and no color entries can be modified).<br/>
		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteSelect(this FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color * *")] FTColor** apalette)
		{
			FTError ret = FreeType.PaletteSelectNative(face, paletteIndex, apalette);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Select<br/>
		/// <br/>
		/// :<br/>
		/// This function has two purposes.<br/>
		/// (1) It activates a palette for rendering color glyphs, and<br/>
		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>
		/// function returns a read-write array, which means that a calling<br/>
		/// application can modify the palette entries on demand.<br/>
		/// A corollary of (2) is that calling the function, then modifying some<br/>
		/// values, then calling the function again with the same arguments resets<br/>
		/// all color entries to the original 'CPAL' values; all user modifications<br/>
		/// are lost.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// palette_index ::<br/>
		/// The palette index.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// An array of color entries for a palette with index `palette_index`,<br/>
		/// having `num_palette_entries` elements (as found in the<br/>
		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>
		/// array gets returned (and no color entries can be modified).<br/>
		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteSelect(this FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color * *")] ref FTColor* apalette)
		{
			fixed (FTColor** papalette = &apalette)
			{
				FTError ret = FreeType.PaletteSelectNative(face, paletteIndex, (FTColor**)papalette);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Set_Foreground_Color<br/>
		/// <br/>
		/// :<br/>
		/// 'COLR' uses palette index 0xFFFF to indicate a 'text foreground<br/>
		/// color'.  This function sets this value.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// foreground_color ::<br/>
		/// An `FT_Color` structure to define the text foreground color.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Set_Foreground_Color")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteSetForegroundColor(this FTFace face, [NativeName(NativeNameType.Param, "foreground_color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor foregroundColor)
		{
			FTError ret = FreeType.PaletteSetForegroundColorNative(face, foregroundColor);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer(this FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator)
		{
			byte ret = FreeType.GetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, acolorIndex, iterator);
			return ret;
		}
	}
}
