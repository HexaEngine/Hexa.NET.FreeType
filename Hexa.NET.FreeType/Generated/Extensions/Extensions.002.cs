// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public static unsafe partial class Extensions
	{

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				int ret = FreeType.FTStrokerCubicToNative(stroker, control1, control2, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FreeType.FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				fixed (FTVector* pto = &to)
				{
					int ret = FreeType.FTStrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int CubicTo(this FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					fixed (FTVector* pto = &to)
					{
						int ret = FreeType.FTStrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, (FTVector*)pto);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, anumPoints, anumContours);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetBorderCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					int ret = FreeType.FTStrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ExportBorder<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export the<br/>
		/// corresponding border to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// <br/>
		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>
		/// independent 'border' outlines, named 'left' and 'right'.<br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_Export instead if you want to retrieve<br/>
		/// all borders at once.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ExportBorder(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FreeType.FTStrokerExportBorderNative(stroker, border, outline);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ExportBorder<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export the<br/>
		/// corresponding border to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// <br/>
		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>
		/// independent 'border' outlines, named 'left' and 'right'.<br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_Export instead if you want to retrieve<br/>
		/// all borders at once.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ExportBorder(this FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FreeType.FTStrokerExportBorderNative(stroker, border, (FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			int ret = FreeType.FTStrokerGetCountsNative(stroker, anumPoints, anumContours);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				int ret = FreeType.FTStrokerGetCountsNative(stroker, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				int ret = FreeType.FTStrokerGetCountsNative(stroker, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static int GetCounts(this FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					int ret = FreeType.FTStrokerGetCountsNative(stroker, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Export<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export all<br/>
		/// borders to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Export(this FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FreeType.FTStrokerExportNative(stroker, outline);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Export<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export all<br/>
		/// borders to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Export(this FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FreeType.FTStrokerExportNative(stroker, (FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.  Can be `NULL`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Done")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Done(this FTStroker stroker)
		{
			FreeType.FTStrokerDoneNative(stroker);
		}

	}
}
