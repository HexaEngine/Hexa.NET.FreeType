// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public unsafe partial class FreeType
	{

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, pTransform);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, pTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, pTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (FTMatrix* ppTransform = &pTransform)
			{
				FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, parg2, (FTMatrix*)ppTransform);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, parg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* pparg2 = &parg2)
			{
				fixed (FTMatrix* ppTransform = &pTransform)
				{
					FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] int* parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, parg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* pparg1 = &parg1)
			{
				fixed (int* pparg2 = &parg2)
				{
					fixed (FTMatrix* ppTransform = &pTransform)
					{
						FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, pFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] int* pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (uint* ppFlags = &pFlags)
			{
				fixed (int* pparg1 = &parg1)
				{
					fixed (int* pparg2 = &parg2)
					{
						fixed (FTMatrix* ppTransform = &pTransform)
						{
							FTError ret = GetSubGlyphInfoNative(glyph, subIndex, pIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
							return ret;
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_SubGlyph_Info<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a description of a given subglyph.  Only use it if<br/>
		/// `glyph->format` is <br/>
		/// _GLYPH_FORMAT_COMPOSITE; an error is returned<br/>
		/// otherwise.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// The source glyph slot.<br/>
		/// sub_index ::<br/>
		/// The index of the subglyph.  Must be less than<br/>
		/// `glyph->num_subglyphs`.<br/>
		/// <br/>
		/// :<br/>
		/// p_index ::<br/>
		/// The glyph index of the subglyph.<br/>
		/// p_flags ::<br/>
		/// The subglyph flags, see <br/>
		/// _SUBGLYPH_FLAG_XXX.<br/>
		/// p_arg1 ::<br/>
		/// The subglyph's first argument (if any).<br/>
		/// p_arg2 ::<br/>
		/// The subglyph's second argument (if any).<br/>
		/// p_transform ::<br/>
		/// The subglyph transformation (if any).<br/>
		/// <br/>
		/// <br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#composite-glyph-description<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_SubGlyph_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSubGlyphInfo([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot glyph, [NativeName(NativeNameType.Param, "sub_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint subIndex, [NativeName(NativeNameType.Param, "p_index")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int pIndex, [NativeName(NativeNameType.Param, "p_flags")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint pFlags, [NativeName(NativeNameType.Param, "p_arg1")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg1, [NativeName(NativeNameType.Param, "p_arg2")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int parg2, [NativeName(NativeNameType.Param, "p_transform")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix pTransform)
		{
			fixed (int* ppIndex = &pIndex)
			{
				fixed (uint* ppFlags = &pFlags)
				{
					fixed (int* pparg1 = &parg1)
					{
						fixed (int* pparg2 = &parg2)
						{
							fixed (FTMatrix* ppTransform = &pTransform)
							{
								FTError ret = GetSubGlyphInfoNative(glyph, subIndex, (int*)ppIndex, (uint*)ppFlags, (int*)pparg1, (int*)pparg2, (FTMatrix*)ppTransform);
								return ret;
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_FSType_Flags<br/>
		/// <br/>
		/// :<br/>
		/// Return the `fsType` flags for a font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetFSTypeFlagsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, ushort>)funcTable[32])(face);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<FTFace, ushort>)funcTable[32])(face);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_FSType_Flags<br/>
		/// <br/>
		/// :<br/>
		/// Return the `fsType` flags for a font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_FSType_Flags")]
		[return: NativeName(NativeNameType.Type, "FT_UShort")]
		public static ushort GetFSTypeFlags([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			ushort ret = GetFSTypeFlagsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIndex<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given character code as modified by the<br/>
		/// variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character code point in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode code point of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// This function is only meaningful if<br/>
		/// a) the font has a variation selector cmap sub table, and<br/>
		/// b) the current charmap has a Unicode encoding.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint FaceGetCharVariantIndexNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, uint, uint>)funcTable[33])(face, charcode, variantSelector);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<FTFace, uint, uint, uint>)funcTable[33])(face, charcode, variantSelector);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIndex<br/>
		/// <br/>
		/// :<br/>
		/// Return the glyph index of a given character code as modified by the<br/>
		/// variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character code point in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode code point of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// This function is only meaningful if<br/>
		/// a) the font has a variation selector cmap sub table, and<br/>
		/// b) the current charmap has a Unicode encoding.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIndex")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint FaceGetCharVariantIndex([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint ret = FaceGetCharVariantIndexNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIsDefault<br/>
		/// <br/>
		/// :<br/>
		/// Check whether this variation of this Unicode character is the one to<br/>
		/// be found in the charmap.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode codepoint of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FaceGetCharVariantIsDefaultNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, uint, int>)funcTable[34])(face, charcode, variantSelector);
			#else
			return (int)((delegate* unmanaged[Cdecl]<FTFace, uint, uint, int>)funcTable[34])(face, charcode, variantSelector);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharVariantIsDefault<br/>
		/// <br/>
		/// :<br/>
		/// Check whether this variation of this Unicode character is the one to<br/>
		/// be found in the charmap.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// variantSelector ::<br/>
		/// The Unicode codepoint of the variation selector.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharVariantIsDefault")]
		[return: NativeName(NativeNameType.Type, "FT_Int")]
		public static int FaceGetCharVariantIsDefault([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			int ret = FaceGetCharVariantIsDefaultNative(face, charcode, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantSelectors<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found in<br/>
		/// the font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* FaceGetVariantSelectorsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint*>)funcTable[35])(face);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<FTFace, nint>)funcTable[35])(face);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantSelectors<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found in<br/>
		/// the font.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantSelectors")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		public static uint* FaceGetVariantSelectors([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			uint* ret = FaceGetVariantSelectorsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantsOfChar<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found for<br/>
		/// the specified character code.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* FaceGetVariantsOfCharNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, uint*>)funcTable[36])(face, charcode);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<FTFace, uint, nint>)funcTable[36])(face, charcode);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetVariantsOfChar<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode variation selectors found for<br/>
		/// the specified character code.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// charcode ::<br/>
		/// The character codepoint in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetVariantsOfChar")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		public static uint* FaceGetVariantsOfChar([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "charcode")] [NativeName(NativeNameType.Type, "FT_ULong")] uint charcode)
		{
			uint* ret = FaceGetVariantsOfCharNative(face, charcode);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharsOfVariant<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode character codes found for the<br/>
		/// specified variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// variantSelector ::<br/>
		/// The variation selector code point in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint* FaceGetCharsOfVariantNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, uint*>)funcTable[37])(face, variantSelector);
			#else
			return (uint*)((delegate* unmanaged[Cdecl]<FTFace, uint, nint>)funcTable[37])(face, variantSelector);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_GetCharsOfVariant<br/>
		/// <br/>
		/// :<br/>
		/// Return a zero-terminated list of Unicode character codes found for the<br/>
		/// specified variation selector.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face object.<br/>
		/// variantSelector ::<br/>
		/// The variation selector code point in Unicode.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_GetCharsOfVariant")]
		[return: NativeName(NativeNameType.Type, "FT_UInt32 *")]
		public static uint* FaceGetCharsOfVariant([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "variantSelector")] [NativeName(NativeNameType.Type, "FT_ULong")] uint variantSelector)
		{
			uint* ret = FaceGetCharsOfVariantNative(face, variantSelector);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_MulDiv<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate<br/>
		/// integer whenever necessary.<br/>
		/// This function isn't necessarily as fast as some processor-specific<br/>
		/// operations, but is at least completely portable.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The first multiplier.<br/>
		/// b ::<br/>
		/// The second multiplier.<br/>
		/// c ::<br/>
		/// The divisor.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_MulDiv")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MulDivNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "FT_Long")] int c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[38])(a, b, c);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int, int>)funcTable[38])(a, b, c);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_MulDiv<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*b)/c` with maximum accuracy, using a 64-bit intermediate<br/>
		/// integer whenever necessary.<br/>
		/// This function isn't necessarily as fast as some processor-specific<br/>
		/// operations, but is at least completely portable.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The first multiplier.<br/>
		/// b ::<br/>
		/// The second multiplier.<br/>
		/// c ::<br/>
		/// The divisor.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_MulDiv")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int MulDiv([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b, [NativeName(NativeNameType.Param, "c")] [NativeName(NativeNameType.Type, "FT_Long")] int c)
		{
			int ret = MulDivNative(a, b, c);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_MulFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to<br/>
		/// multiply a given value by a 16.16 fixed-point factor.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The first multiplier.<br/>
		/// b ::<br/>
		/// The second multiplier.  Use a 16.16 factor here whenever possible<br/>
		/// (see note below).<br/>
		/// <br/>
		/// <br/>
		/// As a conclusion, always try to place a 16.16 factor as the _second_<br/>
		/// argument of this function; this can make a great difference.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_MulFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int MulFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[39])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[39])(a, b);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_MulFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*b)/0x10000` with maximum accuracy.  Its main use is to<br/>
		/// multiply a given value by a 16.16 fixed-point factor.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The first multiplier.<br/>
		/// b ::<br/>
		/// The second multiplier.  Use a 16.16 factor here whenever possible<br/>
		/// (see note below).<br/>
		/// <br/>
		/// <br/>
		/// As a conclusion, always try to place a 16.16 factor as the _second_<br/>
		/// argument of this function; this can make a great difference.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_MulFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int MulFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b)
		{
			int ret = MulFixNative(a, b);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_DivFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to<br/>
		/// divide a given value by a 16.16 fixed-point factor.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The numerator.<br/>
		/// b ::<br/>
		/// The denominator.  Use a 16.16 factor here.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_DivFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int DivFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[40])(a, b);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[40])(a, b);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_DivFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute `(a*0x10000)/b` with maximum accuracy.  Its main use is to<br/>
		/// divide a given value by a 16.16 fixed-point factor.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The numerator.<br/>
		/// b ::<br/>
		/// The denominator.  Use a 16.16 factor here.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_DivFix")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int DivFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Long")] int a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Long")] int b)
		{
			int ret = DivFixNative(a, b);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_RoundFix<br/>
		/// <br/>
		/// :<br/>
		/// Round a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number to be rounded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_RoundFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RoundFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[41])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[41])(a);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_RoundFix<br/>
		/// <br/>
		/// :<br/>
		/// Round a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number to be rounded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_RoundFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int RoundFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			int ret = RoundFixNative(a);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_CeilFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute the smallest following integer of a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number for which the ceiling function is to be computed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_CeilFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CeilFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[42])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[42])(a);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_CeilFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute the smallest following integer of a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number for which the ceiling function is to be computed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_CeilFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int CeilFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			int ret = CeilFixNative(a);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_FloorFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute the largest previous integer of a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number for which the floor function is to be computed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_FloorFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int FloorFixNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[43])(a);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[43])(a);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_FloorFix<br/>
		/// <br/>
		/// :<br/>
		/// Compute the largest previous integer of a 16.16 fixed number.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// The number for which the floor function is to be computed.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_FloorFix")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int FloorFix([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Fixed")] int a)
		{
			int ret = FloorFixNative(a);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a single vector through a 2x2 matrix.<br/>
		/// <br/>
		/// :<br/>
		/// vector ::<br/>
		/// The target vector to transform.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the source 2x2 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VectorTransformNative([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTVector*, FTMatrix*, void>)funcTable[44])(vector, matrix);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[44])((nint)vector, (nint)matrix);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a single vector through a 2x2 matrix.<br/>
		/// <br/>
		/// :<br/>
		/// vector ::<br/>
		/// The target vector to transform.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the source 2x2 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorTransform([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix)
		{
			VectorTransformNative(vector, matrix);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a single vector through a 2x2 matrix.<br/>
		/// <br/>
		/// :<br/>
		/// vector ::<br/>
		/// The target vector to transform.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the source 2x2 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorTransform([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix)
		{
			fixed (FTVector* pvector = &vector)
			{
				VectorTransformNative((FTVector*)pvector, matrix);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a single vector through a 2x2 matrix.<br/>
		/// <br/>
		/// :<br/>
		/// vector ::<br/>
		/// The target vector to transform.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the source 2x2 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorTransform([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix matrix)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				VectorTransformNative(vector, (FTMatrix*)pmatrix);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a single vector through a 2x2 matrix.<br/>
		/// <br/>
		/// :<br/>
		/// vector ::<br/>
		/// The target vector to transform.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the source 2x2 matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorTransform([NativeName(NativeNameType.Param, "vector")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vector, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix matrix)
		{
			fixed (FTVector* pvector = &vector)
			{
				fixed (FTMatrix* pmatrix = &matrix)
				{
					VectorTransformNative((FTVector*)pvector, (FTMatrix*)pmatrix);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LibraryVersionNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTLibrary, int*, int*, int*, void>)funcTable[45])(library, amajor, aminor, apatch);
			#else
			((delegate* unmanaged[Cdecl]<FTLibrary, nint, nint, nint, void>)funcTable[45])(library, (nint)amajor, (nint)aminor, (nint)apatch);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			LibraryVersionNative(library, amajor, aminor, apatch);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				LibraryVersionNative(library, (int*)pamajor, aminor, apatch);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			fixed (int* paminor = &aminor)
			{
				LibraryVersionNative(library, amajor, (int*)paminor, apatch);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] int* apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					LibraryVersionNative(library, (int*)pamajor, (int*)paminor, apatch);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* papatch = &apatch)
			{
				LibraryVersionNative(library, amajor, aminor, (int*)papatch);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* papatch = &apatch)
				{
					LibraryVersionNative(library, (int*)pamajor, aminor, (int*)papatch);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] int* amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* paminor = &aminor)
			{
				fixed (int* papatch = &apatch)
				{
					LibraryVersionNative(library, amajor, (int*)paminor, (int*)papatch);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Library_Version<br/>
		/// <br/>
		/// :<br/>
		/// Return the version of the FreeType library being used.  This is useful<br/>
		/// when dynamically linking to the library, since one cannot use the<br/>
		/// macros <br/>
		/// _MAJOR, <br/>
		/// _MINOR, and <br/>
		/// _PATCH.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A source library handle.<br/>
		/// <br/>
		/// :<br/>
		/// amajor ::<br/>
		/// The major version number.<br/>
		/// aminor ::<br/>
		/// The minor version number.<br/>
		/// apatch ::<br/>
		/// The patch version number.<br/>
		/// <br/>
		/// In such cases, the library version might not be available before the<br/>
		/// library object has been created.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Library_Version")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void LibraryVersion([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "amajor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int amajor, [NativeName(NativeNameType.Param, "aminor")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int aminor, [NativeName(NativeNameType.Param, "apatch")] [NativeName(NativeNameType.Type, "FT_Int *")] ref int apatch)
		{
			fixed (int* pamajor = &amajor)
			{
				fixed (int* paminor = &aminor)
				{
					fixed (int* papatch = &apatch)
					{
						LibraryVersionNative(library, (int*)pamajor, (int*)paminor, (int*)papatch);
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_CheckTrueTypePatents<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FaceCheckTrueTypePatentsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, byte>)funcTable[46])(face);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, byte>)funcTable[46])(face);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_CheckTrueTypePatents<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_CheckTrueTypePatents")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FaceCheckTrueTypePatents([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			byte ret = FaceCheckTrueTypePatentsNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_SetUnpatentedHinting<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// value ::<br/>
		/// New boolean setting.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte FaceSetUnpatentedHintingNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, byte, byte>)funcTable[47])(face, value);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, byte, byte>)funcTable[47])(face, value);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Face_SetUnpatentedHinting<br/>
		/// <br/>
		/// :<br/>
		/// Deprecated, does nothing.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A face handle.<br/>
		/// value ::<br/>
		/// New boolean setting.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Face_SetUnpatentedHinting")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte FaceSetUnpatentedHinting([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "FT_Bool")] byte value)
		{
			byte ret = FaceSetUnpatentedHintingNative(face, value);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to create a new empty glyph image.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the FreeType library object.<br/>
		/// format ::<br/>
		/// The format of the glyph's image.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError NewGlyphNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* aglyph)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTGlyphFormat, FTGlyph*, FTError>)funcTable[48])(library, format, aglyph);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, FTGlyphFormat, nint, FTError>)funcTable[48])(library, format, (nint)aglyph);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to create a new empty glyph image.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the FreeType library object.<br/>
		/// format ::<br/>
		/// The format of the glyph's image.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewGlyph([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* aglyph)
		{
			FTError ret = NewGlyphNative(library, format, aglyph);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_New_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to create a new empty glyph image.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the FreeType library object.<br/>
		/// format ::<br/>
		/// The format of the glyph's image.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_New_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError NewGlyph([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "format")] [NativeName(NativeNameType.Type, "FT_Glyph_Format")] FTGlyphFormat format, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph aglyph)
		{
			fixed (FTGlyph* paglyph = &aglyph)
			{
				FTError ret = NewGlyphNative(library, format, (FTGlyph*)paglyph);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to extract a glyph image from a slot.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// slot ::<br/>
		/// A handle to the source glyph slot.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.  `NULL` in case of error.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GetGlyphNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* aglyph)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyphSlot, FTGlyph*, FTError>)funcTable[49])(slot, aglyph);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTGlyphSlot, nint, FTError>)funcTable[49])(slot, (nint)aglyph);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to extract a glyph image from a slot.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// slot ::<br/>
		/// A handle to the source glyph slot.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.  `NULL` in case of error.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetGlyph([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* aglyph)
		{
			FTError ret = GetGlyphNative(slot, aglyph);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// A function used to extract a glyph image from a slot.  Note that the<br/>
		/// created <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// slot ::<br/>
		/// A handle to the source glyph slot.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph ::<br/>
		/// A handle to the glyph object.  `NULL` in case of error.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Glyph")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetGlyph([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "aglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph aglyph)
		{
			fixed (FTGlyph* paglyph = &aglyph)
			{
				FTError ret = GetGlyphNative(slot, (FTGlyph*)paglyph);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Copy<br/>
		/// <br/>
		/// :<br/>
		/// A function used to copy a glyph image.  Note that the created<br/>
		/// <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target glyph object.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GlyphCopyNative([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyph, FTGlyph*, FTError>)funcTable[50])(source, target);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTGlyph, nint, FTError>)funcTable[50])(source, (nint)target);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Copy<br/>
		/// <br/>
		/// :<br/>
		/// A function used to copy a glyph image.  Note that the created<br/>
		/// <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target glyph object.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphCopy([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* target)
		{
			FTError ret = GlyphCopyNative(source, target);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Copy<br/>
		/// <br/>
		/// :<br/>
		/// A function used to copy a glyph image.  Note that the created<br/>
		/// <br/>
		/// _Glyph object must be released with <br/>
		/// _Done_Glyph.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target glyph object.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphCopy([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph target)
		{
			fixed (FTGlyph* ptarget = &target)
			{
				FTError ret = GlyphCopyNative(source, (FTGlyph*)ptarget);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a glyph image if its format is scalable.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a 2x2 matrix to apply.<br/>
		/// delta ::<br/>
		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>
		/// 1/64 of a pixel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GlyphTransformNative([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector const *")] FTVector* delta)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyph, FTMatrix*, FTVector*, FTError>)funcTable[51])(glyph, matrix, delta);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTGlyph, nint, nint, FTError>)funcTable[51])(glyph, (nint)matrix, (nint)delta);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a glyph image if its format is scalable.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a 2x2 matrix to apply.<br/>
		/// delta ::<br/>
		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>
		/// 1/64 of a pixel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphTransform([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector const *")] FTVector* delta)
		{
			FTError ret = GlyphTransformNative(glyph, matrix, delta);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a glyph image if its format is scalable.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a 2x2 matrix to apply.<br/>
		/// delta ::<br/>
		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>
		/// 1/64 of a pixel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphTransform([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector const *")] FTVector* delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FTError ret = GlyphTransformNative(glyph, (FTMatrix*)pmatrix, delta);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a glyph image if its format is scalable.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a 2x2 matrix to apply.<br/>
		/// delta ::<br/>
		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>
		/// 1/64 of a pixel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphTransform([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector const *")] ref FTVector delta)
		{
			fixed (FTVector* pdelta = &delta)
			{
				FTError ret = GlyphTransformNative(glyph, matrix, (FTVector*)pdelta);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Transform a glyph image if its format is scalable.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to a 2x2 matrix to apply.<br/>
		/// delta ::<br/>
		/// A pointer to a 2d vector to apply.  Coordinates are expressed in<br/>
		/// 1/64 of a pixel.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Transform")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphTransform([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix matrix, [NativeName(NativeNameType.Param, "delta")] [NativeName(NativeNameType.Type, "FT_Vector const *")] ref FTVector delta)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				fixed (FTVector* pdelta = &delta)
				{
					FTError ret = GlyphTransformNative(glyph, (FTMatrix*)pmatrix, (FTVector*)pdelta);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return a glyph's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the source glyph object.<br/>
		/// mode ::<br/>
		/// The mode that indicates how to interpret the returned bounding box<br/>
		/// values.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The glyph coordinate bounding box.  Coordinates are expressed in<br/>
		/// 1/64 of pixels if it is grid-fitted.<br/>
		/// <br/>
		/// If the glyph has been loaded with <br/>
		/// _LOAD_NO_SCALE, `bbox_mode` must<br/>
		/// be set to <br/>
		/// _GLYPH_BBOX_UNSCALED to get unscaled font units in 26.6<br/>
		/// pixel format.  The value <br/>
		/// _GLYPH_BBOX_SUBPIXELS is another name for<br/>
		/// this constant.<br/>
		/// If the font is tricky and the glyph has been loaded with<br/>
		/// <br/>
		/// _LOAD_NO_SCALE, the resulting CBox is meaningless.  To get<br/>
		/// reasonable values for the CBox it is necessary to load the glyph at a<br/>
		/// large ppem value (so that the hinting instructions can properly shift<br/>
		/// and scale the subglyphs), then extracting the CBox, which can be<br/>
		/// eventually converted back to font units.<br/>
		/// Note that the maximum coordinates are exclusive, which means that one<br/>
		/// can compute the width and height of the glyph image (be it in integer<br/>
		/// or 26.6 pixels) as:<br/>
		/// ```<br/>
		/// width  = bbox.xMax - bbox.xMin;<br/>
		/// height = bbox.yMax - bbox.yMin;<br/>
		/// ```<br/>
		/// Note also that for 26.6 coordinates, if `bbox_mode` is set to<br/>
		/// <br/>
		/// _GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted,<br/>
		/// which corresponds to:<br/>
		/// ```<br/>
		/// bbox.xMin = FLOOR(bbox.xMin);<br/>
		/// bbox.yMin = FLOOR(bbox.yMin);<br/>
		/// bbox.xMax = CEILING(bbox.xMax);<br/>
		/// bbox.yMax = CEILING(bbox.yMax);<br/>
		/// ```<br/>
		/// To get the bbox in pixel coordinates, set `bbox_mode` to<br/>
		/// <br/>
		/// _GLYPH_BBOX_TRUNCATE.<br/>
		/// To get the bbox in grid-fitted pixel coordinates, set `bbox_mode` to<br/>
		/// <br/>
		/// _GLYPH_BBOX_PIXELS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlyphGetCBoxNative([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "bbox_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bboxMode, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* acbox)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTGlyph, uint, FTBBox*, void>)funcTable[52])(glyph, bboxMode, acbox);
			#else
			((delegate* unmanaged[Cdecl]<FTGlyph, uint, nint, void>)funcTable[52])(glyph, bboxMode, (nint)acbox);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return a glyph's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the source glyph object.<br/>
		/// mode ::<br/>
		/// The mode that indicates how to interpret the returned bounding box<br/>
		/// values.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The glyph coordinate bounding box.  Coordinates are expressed in<br/>
		/// 1/64 of pixels if it is grid-fitted.<br/>
		/// <br/>
		/// If the glyph has been loaded with <br/>
		/// _LOAD_NO_SCALE, `bbox_mode` must<br/>
		/// be set to <br/>
		/// _GLYPH_BBOX_UNSCALED to get unscaled font units in 26.6<br/>
		/// pixel format.  The value <br/>
		/// _GLYPH_BBOX_SUBPIXELS is another name for<br/>
		/// this constant.<br/>
		/// If the font is tricky and the glyph has been loaded with<br/>
		/// <br/>
		/// _LOAD_NO_SCALE, the resulting CBox is meaningless.  To get<br/>
		/// reasonable values for the CBox it is necessary to load the glyph at a<br/>
		/// large ppem value (so that the hinting instructions can properly shift<br/>
		/// and scale the subglyphs), then extracting the CBox, which can be<br/>
		/// eventually converted back to font units.<br/>
		/// Note that the maximum coordinates are exclusive, which means that one<br/>
		/// can compute the width and height of the glyph image (be it in integer<br/>
		/// or 26.6 pixels) as:<br/>
		/// ```<br/>
		/// width  = bbox.xMax - bbox.xMin;<br/>
		/// height = bbox.yMax - bbox.yMin;<br/>
		/// ```<br/>
		/// Note also that for 26.6 coordinates, if `bbox_mode` is set to<br/>
		/// <br/>
		/// _GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted,<br/>
		/// which corresponds to:<br/>
		/// ```<br/>
		/// bbox.xMin = FLOOR(bbox.xMin);<br/>
		/// bbox.yMin = FLOOR(bbox.yMin);<br/>
		/// bbox.xMax = CEILING(bbox.xMax);<br/>
		/// bbox.yMax = CEILING(bbox.yMax);<br/>
		/// ```<br/>
		/// To get the bbox in pixel coordinates, set `bbox_mode` to<br/>
		/// <br/>
		/// _GLYPH_BBOX_TRUNCATE.<br/>
		/// To get the bbox in grid-fitted pixel coordinates, set `bbox_mode` to<br/>
		/// <br/>
		/// _GLYPH_BBOX_PIXELS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GlyphGetCBox([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "bbox_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bboxMode, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* acbox)
		{
			GlyphGetCBoxNative(glyph, bboxMode, acbox);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return a glyph's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the source glyph object.<br/>
		/// mode ::<br/>
		/// The mode that indicates how to interpret the returned bounding box<br/>
		/// values.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The glyph coordinate bounding box.  Coordinates are expressed in<br/>
		/// 1/64 of pixels if it is grid-fitted.<br/>
		/// <br/>
		/// If the glyph has been loaded with <br/>
		/// _LOAD_NO_SCALE, `bbox_mode` must<br/>
		/// be set to <br/>
		/// _GLYPH_BBOX_UNSCALED to get unscaled font units in 26.6<br/>
		/// pixel format.  The value <br/>
		/// _GLYPH_BBOX_SUBPIXELS is another name for<br/>
		/// this constant.<br/>
		/// If the font is tricky and the glyph has been loaded with<br/>
		/// <br/>
		/// _LOAD_NO_SCALE, the resulting CBox is meaningless.  To get<br/>
		/// reasonable values for the CBox it is necessary to load the glyph at a<br/>
		/// large ppem value (so that the hinting instructions can properly shift<br/>
		/// and scale the subglyphs), then extracting the CBox, which can be<br/>
		/// eventually converted back to font units.<br/>
		/// Note that the maximum coordinates are exclusive, which means that one<br/>
		/// can compute the width and height of the glyph image (be it in integer<br/>
		/// or 26.6 pixels) as:<br/>
		/// ```<br/>
		/// width  = bbox.xMax - bbox.xMin;<br/>
		/// height = bbox.yMax - bbox.yMin;<br/>
		/// ```<br/>
		/// Note also that for 26.6 coordinates, if `bbox_mode` is set to<br/>
		/// <br/>
		/// _GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted,<br/>
		/// which corresponds to:<br/>
		/// ```<br/>
		/// bbox.xMin = FLOOR(bbox.xMin);<br/>
		/// bbox.yMin = FLOOR(bbox.yMin);<br/>
		/// bbox.xMax = CEILING(bbox.xMax);<br/>
		/// bbox.yMax = CEILING(bbox.yMax);<br/>
		/// ```<br/>
		/// To get the bbox in pixel coordinates, set `bbox_mode` to<br/>
		/// <br/>
		/// _GLYPH_BBOX_TRUNCATE.<br/>
		/// To get the bbox in grid-fitted pixel coordinates, set `bbox_mode` to<br/>
		/// <br/>
		/// _GLYPH_BBOX_PIXELS.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GlyphGetCBox([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph, [NativeName(NativeNameType.Param, "bbox_mode")] [NativeName(NativeNameType.Type, "FT_UInt")] uint bboxMode, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] ref FTBBox acbox)
		{
			fixed (FTBBox* pacbox = &acbox)
			{
				GlyphGetCBoxNative(glyph, bboxMode, (FTBBox*)pacbox);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_To_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Convert a given glyph object to a bitmap glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// the_glyph ::<br/>
		/// A pointer to a handle to the target glyph.<br/>
		/// <br/>
		/// :<br/>
		/// render_mode ::<br/>
		/// An enumeration that describes how the data is rendered.<br/>
		/// origin ::<br/>
		/// A pointer to a vector used to translate the glyph image before<br/>
		/// rendering.  Can be~0 (if no translation).  The origin is expressed<br/>
		/// in 26.6 pixels.<br/>
		/// destroy ::<br/>
		/// A boolean that indicates that the original glyph image should be<br/>
		/// destroyed by this function.  It is never destroyed in case of error.<br/>
		/// <br/>
		/// <br/>
		/// The glyph image is translated with the `origin` vector before<br/>
		/// rendering.<br/>
		/// The first parameter is a pointer to an <br/>
		/// _Glyph handle that will be<br/>
		/// _replaced_ by this function (with newly allocated data).  Typically,<br/>
		/// you would do something like the following (omitting error handling).<br/>
		/// ```<br/>
		/// FT_Glyph        glyph;<br/>
		/// FT_BitmapGlyph  glyph_bitmap;<br/>
		/// // load glyph<br/>
		/// error = FT_Load_Char( face, glyph_index, FT_LOAD_DEFAULT );<br/>
		/// // extract glyph image<br/>
		/// error = FT_Get_Glyph( face->glyph, <br/>
		/// &glyph<br/>
		/// );<br/>
		/// // convert to a bitmap (default render mode + destroying old)<br/>
		/// if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )<br/>
		/// {<br/>
		/// error = FT_Glyph_To_Bitmap( <br/>
		/// &glyph<br/>
		/// , FT_RENDER_MODE_NORMAL,<br/>
		/// 0, 1 );<br/>
		/// if ( error ) // `glyph' unchanged<br/>
		/// ...<br/>
		/// }<br/>
		/// // access bitmap content by typecasting<br/>
		/// glyph_bitmap = (FT_BitmapGlyph)glyph;<br/>
		/// // do funny stuff with it, like blitting/drawing<br/>
		/// ...<br/>
		/// // discard glyph image (bitmap or not)<br/>
		/// FT_Done_Glyph( glyph );<br/>
		/// ```<br/>
		/// Here is another example, again without error handling.<br/>
		/// ```<br/>
		/// FT_Glyph  glyphs[MAX_GLYPHS]<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// error = FT_Load_Glyph( face, idx, FT_LOAD_DEFAULT ) ||<br/>
		/// FT_Get_Glyph ( face->glyph, <br/>
		/// &glyphs<br/>
		/// [idx] );<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// {<br/>
		/// FT_Glyph  bitmap = glyphs[idx];<br/>
		/// ...<br/>
		/// // after this call, `bitmap' no longer points into<br/>
		/// // the `glyphs' array (and the old value isn't destroyed)<br/>
		/// FT_Glyph_To_Bitmap( <br/>
		/// &bitmap<br/>
		/// , FT_RENDER_MODE_MONO, 0, 0 );<br/>
		/// ...<br/>
		/// FT_Done_Glyph( bitmap );<br/>
		/// }<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// FT_Done_Glyph( glyphs[idx] );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_To_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GlyphToBitmapNative([NativeName(NativeNameType.Param, "the_glyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* theGlyph, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "FT_Vector const *")] FTVector* origin, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyph*, FTRenderMode, FTVector*, byte, FTError>)funcTable[53])(theGlyph, renderMode, origin, destroy);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, FTRenderMode, nint, byte, FTError>)funcTable[53])((nint)theGlyph, renderMode, (nint)origin, destroy);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_To_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Convert a given glyph object to a bitmap glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// the_glyph ::<br/>
		/// A pointer to a handle to the target glyph.<br/>
		/// <br/>
		/// :<br/>
		/// render_mode ::<br/>
		/// An enumeration that describes how the data is rendered.<br/>
		/// origin ::<br/>
		/// A pointer to a vector used to translate the glyph image before<br/>
		/// rendering.  Can be~0 (if no translation).  The origin is expressed<br/>
		/// in 26.6 pixels.<br/>
		/// destroy ::<br/>
		/// A boolean that indicates that the original glyph image should be<br/>
		/// destroyed by this function.  It is never destroyed in case of error.<br/>
		/// <br/>
		/// <br/>
		/// The glyph image is translated with the `origin` vector before<br/>
		/// rendering.<br/>
		/// The first parameter is a pointer to an <br/>
		/// _Glyph handle that will be<br/>
		/// _replaced_ by this function (with newly allocated data).  Typically,<br/>
		/// you would do something like the following (omitting error handling).<br/>
		/// ```<br/>
		/// FT_Glyph        glyph;<br/>
		/// FT_BitmapGlyph  glyph_bitmap;<br/>
		/// // load glyph<br/>
		/// error = FT_Load_Char( face, glyph_index, FT_LOAD_DEFAULT );<br/>
		/// // extract glyph image<br/>
		/// error = FT_Get_Glyph( face->glyph, <br/>
		/// &glyph<br/>
		/// );<br/>
		/// // convert to a bitmap (default render mode + destroying old)<br/>
		/// if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )<br/>
		/// {<br/>
		/// error = FT_Glyph_To_Bitmap( <br/>
		/// &glyph<br/>
		/// , FT_RENDER_MODE_NORMAL,<br/>
		/// 0, 1 );<br/>
		/// if ( error ) // `glyph' unchanged<br/>
		/// ...<br/>
		/// }<br/>
		/// // access bitmap content by typecasting<br/>
		/// glyph_bitmap = (FT_BitmapGlyph)glyph;<br/>
		/// // do funny stuff with it, like blitting/drawing<br/>
		/// ...<br/>
		/// // discard glyph image (bitmap or not)<br/>
		/// FT_Done_Glyph( glyph );<br/>
		/// ```<br/>
		/// Here is another example, again without error handling.<br/>
		/// ```<br/>
		/// FT_Glyph  glyphs[MAX_GLYPHS]<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// error = FT_Load_Glyph( face, idx, FT_LOAD_DEFAULT ) ||<br/>
		/// FT_Get_Glyph ( face->glyph, <br/>
		/// &glyphs<br/>
		/// [idx] );<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// {<br/>
		/// FT_Glyph  bitmap = glyphs[idx];<br/>
		/// ...<br/>
		/// // after this call, `bitmap' no longer points into<br/>
		/// // the `glyphs' array (and the old value isn't destroyed)<br/>
		/// FT_Glyph_To_Bitmap( <br/>
		/// &bitmap<br/>
		/// , FT_RENDER_MODE_MONO, 0, 0 );<br/>
		/// ...<br/>
		/// FT_Done_Glyph( bitmap );<br/>
		/// }<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// FT_Done_Glyph( glyphs[idx] );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_To_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphToBitmap([NativeName(NativeNameType.Param, "the_glyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* theGlyph, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "FT_Vector const *")] FTVector* origin, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			FTError ret = GlyphToBitmapNative(theGlyph, renderMode, origin, destroy);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_To_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Convert a given glyph object to a bitmap glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// the_glyph ::<br/>
		/// A pointer to a handle to the target glyph.<br/>
		/// <br/>
		/// :<br/>
		/// render_mode ::<br/>
		/// An enumeration that describes how the data is rendered.<br/>
		/// origin ::<br/>
		/// A pointer to a vector used to translate the glyph image before<br/>
		/// rendering.  Can be~0 (if no translation).  The origin is expressed<br/>
		/// in 26.6 pixels.<br/>
		/// destroy ::<br/>
		/// A boolean that indicates that the original glyph image should be<br/>
		/// destroyed by this function.  It is never destroyed in case of error.<br/>
		/// <br/>
		/// <br/>
		/// The glyph image is translated with the `origin` vector before<br/>
		/// rendering.<br/>
		/// The first parameter is a pointer to an <br/>
		/// _Glyph handle that will be<br/>
		/// _replaced_ by this function (with newly allocated data).  Typically,<br/>
		/// you would do something like the following (omitting error handling).<br/>
		/// ```<br/>
		/// FT_Glyph        glyph;<br/>
		/// FT_BitmapGlyph  glyph_bitmap;<br/>
		/// // load glyph<br/>
		/// error = FT_Load_Char( face, glyph_index, FT_LOAD_DEFAULT );<br/>
		/// // extract glyph image<br/>
		/// error = FT_Get_Glyph( face->glyph, <br/>
		/// &glyph<br/>
		/// );<br/>
		/// // convert to a bitmap (default render mode + destroying old)<br/>
		/// if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )<br/>
		/// {<br/>
		/// error = FT_Glyph_To_Bitmap( <br/>
		/// &glyph<br/>
		/// , FT_RENDER_MODE_NORMAL,<br/>
		/// 0, 1 );<br/>
		/// if ( error ) // `glyph' unchanged<br/>
		/// ...<br/>
		/// }<br/>
		/// // access bitmap content by typecasting<br/>
		/// glyph_bitmap = (FT_BitmapGlyph)glyph;<br/>
		/// // do funny stuff with it, like blitting/drawing<br/>
		/// ...<br/>
		/// // discard glyph image (bitmap or not)<br/>
		/// FT_Done_Glyph( glyph );<br/>
		/// ```<br/>
		/// Here is another example, again without error handling.<br/>
		/// ```<br/>
		/// FT_Glyph  glyphs[MAX_GLYPHS]<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// error = FT_Load_Glyph( face, idx, FT_LOAD_DEFAULT ) ||<br/>
		/// FT_Get_Glyph ( face->glyph, <br/>
		/// &glyphs<br/>
		/// [idx] );<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// {<br/>
		/// FT_Glyph  bitmap = glyphs[idx];<br/>
		/// ...<br/>
		/// // after this call, `bitmap' no longer points into<br/>
		/// // the `glyphs' array (and the old value isn't destroyed)<br/>
		/// FT_Glyph_To_Bitmap( <br/>
		/// &bitmap<br/>
		/// , FT_RENDER_MODE_MONO, 0, 0 );<br/>
		/// ...<br/>
		/// FT_Done_Glyph( bitmap );<br/>
		/// }<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// FT_Done_Glyph( glyphs[idx] );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_To_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphToBitmap([NativeName(NativeNameType.Param, "the_glyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph theGlyph, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "FT_Vector const *")] FTVector* origin, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			fixed (FTGlyph* ptheGlyph = &theGlyph)
			{
				FTError ret = GlyphToBitmapNative((FTGlyph*)ptheGlyph, renderMode, origin, destroy);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_To_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Convert a given glyph object to a bitmap glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// the_glyph ::<br/>
		/// A pointer to a handle to the target glyph.<br/>
		/// <br/>
		/// :<br/>
		/// render_mode ::<br/>
		/// An enumeration that describes how the data is rendered.<br/>
		/// origin ::<br/>
		/// A pointer to a vector used to translate the glyph image before<br/>
		/// rendering.  Can be~0 (if no translation).  The origin is expressed<br/>
		/// in 26.6 pixels.<br/>
		/// destroy ::<br/>
		/// A boolean that indicates that the original glyph image should be<br/>
		/// destroyed by this function.  It is never destroyed in case of error.<br/>
		/// <br/>
		/// <br/>
		/// The glyph image is translated with the `origin` vector before<br/>
		/// rendering.<br/>
		/// The first parameter is a pointer to an <br/>
		/// _Glyph handle that will be<br/>
		/// _replaced_ by this function (with newly allocated data).  Typically,<br/>
		/// you would do something like the following (omitting error handling).<br/>
		/// ```<br/>
		/// FT_Glyph        glyph;<br/>
		/// FT_BitmapGlyph  glyph_bitmap;<br/>
		/// // load glyph<br/>
		/// error = FT_Load_Char( face, glyph_index, FT_LOAD_DEFAULT );<br/>
		/// // extract glyph image<br/>
		/// error = FT_Get_Glyph( face->glyph, <br/>
		/// &glyph<br/>
		/// );<br/>
		/// // convert to a bitmap (default render mode + destroying old)<br/>
		/// if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )<br/>
		/// {<br/>
		/// error = FT_Glyph_To_Bitmap( <br/>
		/// &glyph<br/>
		/// , FT_RENDER_MODE_NORMAL,<br/>
		/// 0, 1 );<br/>
		/// if ( error ) // `glyph' unchanged<br/>
		/// ...<br/>
		/// }<br/>
		/// // access bitmap content by typecasting<br/>
		/// glyph_bitmap = (FT_BitmapGlyph)glyph;<br/>
		/// // do funny stuff with it, like blitting/drawing<br/>
		/// ...<br/>
		/// // discard glyph image (bitmap or not)<br/>
		/// FT_Done_Glyph( glyph );<br/>
		/// ```<br/>
		/// Here is another example, again without error handling.<br/>
		/// ```<br/>
		/// FT_Glyph  glyphs[MAX_GLYPHS]<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// error = FT_Load_Glyph( face, idx, FT_LOAD_DEFAULT ) ||<br/>
		/// FT_Get_Glyph ( face->glyph, <br/>
		/// &glyphs<br/>
		/// [idx] );<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// {<br/>
		/// FT_Glyph  bitmap = glyphs[idx];<br/>
		/// ...<br/>
		/// // after this call, `bitmap' no longer points into<br/>
		/// // the `glyphs' array (and the old value isn't destroyed)<br/>
		/// FT_Glyph_To_Bitmap( <br/>
		/// &bitmap<br/>
		/// , FT_RENDER_MODE_MONO, 0, 0 );<br/>
		/// ...<br/>
		/// FT_Done_Glyph( bitmap );<br/>
		/// }<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// FT_Done_Glyph( glyphs[idx] );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_To_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphToBitmap([NativeName(NativeNameType.Param, "the_glyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* theGlyph, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "FT_Vector const *")] ref FTVector origin, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			fixed (FTVector* porigin = &origin)
			{
				FTError ret = GlyphToBitmapNative(theGlyph, renderMode, (FTVector*)porigin, destroy);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_To_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Convert a given glyph object to a bitmap glyph object.<br/>
		/// <br/>
		/// :<br/>
		/// the_glyph ::<br/>
		/// A pointer to a handle to the target glyph.<br/>
		/// <br/>
		/// :<br/>
		/// render_mode ::<br/>
		/// An enumeration that describes how the data is rendered.<br/>
		/// origin ::<br/>
		/// A pointer to a vector used to translate the glyph image before<br/>
		/// rendering.  Can be~0 (if no translation).  The origin is expressed<br/>
		/// in 26.6 pixels.<br/>
		/// destroy ::<br/>
		/// A boolean that indicates that the original glyph image should be<br/>
		/// destroyed by this function.  It is never destroyed in case of error.<br/>
		/// <br/>
		/// <br/>
		/// The glyph image is translated with the `origin` vector before<br/>
		/// rendering.<br/>
		/// The first parameter is a pointer to an <br/>
		/// _Glyph handle that will be<br/>
		/// _replaced_ by this function (with newly allocated data).  Typically,<br/>
		/// you would do something like the following (omitting error handling).<br/>
		/// ```<br/>
		/// FT_Glyph        glyph;<br/>
		/// FT_BitmapGlyph  glyph_bitmap;<br/>
		/// // load glyph<br/>
		/// error = FT_Load_Char( face, glyph_index, FT_LOAD_DEFAULT );<br/>
		/// // extract glyph image<br/>
		/// error = FT_Get_Glyph( face->glyph, <br/>
		/// &glyph<br/>
		/// );<br/>
		/// // convert to a bitmap (default render mode + destroying old)<br/>
		/// if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )<br/>
		/// {<br/>
		/// error = FT_Glyph_To_Bitmap( <br/>
		/// &glyph<br/>
		/// , FT_RENDER_MODE_NORMAL,<br/>
		/// 0, 1 );<br/>
		/// if ( error ) // `glyph' unchanged<br/>
		/// ...<br/>
		/// }<br/>
		/// // access bitmap content by typecasting<br/>
		/// glyph_bitmap = (FT_BitmapGlyph)glyph;<br/>
		/// // do funny stuff with it, like blitting/drawing<br/>
		/// ...<br/>
		/// // discard glyph image (bitmap or not)<br/>
		/// FT_Done_Glyph( glyph );<br/>
		/// ```<br/>
		/// Here is another example, again without error handling.<br/>
		/// ```<br/>
		/// FT_Glyph  glyphs[MAX_GLYPHS]<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// error = FT_Load_Glyph( face, idx, FT_LOAD_DEFAULT ) ||<br/>
		/// FT_Get_Glyph ( face->glyph, <br/>
		/// &glyphs<br/>
		/// [idx] );<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// {<br/>
		/// FT_Glyph  bitmap = glyphs[idx];<br/>
		/// ...<br/>
		/// // after this call, `bitmap' no longer points into<br/>
		/// // the `glyphs' array (and the old value isn't destroyed)<br/>
		/// FT_Glyph_To_Bitmap( <br/>
		/// &bitmap<br/>
		/// , FT_RENDER_MODE_MONO, 0, 0 );<br/>
		/// ...<br/>
		/// FT_Done_Glyph( bitmap );<br/>
		/// }<br/>
		/// ...<br/>
		/// for ( idx = 0; i <br/>
		/// <<br/>
		/// MAX_GLYPHS; i++ )<br/>
		/// FT_Done_Glyph( glyphs[idx] );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_To_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphToBitmap([NativeName(NativeNameType.Param, "the_glyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph theGlyph, [NativeName(NativeNameType.Param, "render_mode")] [NativeName(NativeNameType.Type, "FT_Render_Mode")] FTRenderMode renderMode, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "FT_Vector const *")] ref FTVector origin, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			fixed (FTGlyph* ptheGlyph = &theGlyph)
			{
				fixed (FTVector* porigin = &origin)
				{
					FTError ret = GlyphToBitmapNative((FTGlyph*)ptheGlyph, renderMode, (FTVector*)porigin, destroy);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Done_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a given glyph.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.  Can be `NULL`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Done_Glyph")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DoneGlyphNative([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTGlyph, void>)funcTable[54])(glyph);
			#else
			((delegate* unmanaged[Cdecl]<FTGlyph, void>)funcTable[54])(glyph);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Done_Glyph<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a given glyph.<br/>
		/// <br/>
		/// :<br/>
		/// glyph ::<br/>
		/// A handle to the target glyph object.  Can be `NULL`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Done_Glyph")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DoneGlyph([NativeName(NativeNameType.Param, "glyph")] [NativeName(NativeNameType.Type, "FT_Glyph")] FTGlyph glyph)
		{
			DoneGlyphNative(glyph);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Multiply<br/>
		/// <br/>
		/// :<br/>
		/// Perform the matrix operation `b = a*b`.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// A pointer to matrix `a`.<br/>
		/// <br/>
		/// :<br/>
		/// b ::<br/>
		/// A pointer to matrix `b`.<br/>
		/// <br/>
		/// Since the function uses wrap-around arithmetic, results become<br/>
		/// meaningless if the arguments are very large.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Multiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultiplyNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* b)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTMatrix*, FTMatrix*, void>)funcTable[55])(a, b);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[55])((nint)a, (nint)b);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Multiply<br/>
		/// <br/>
		/// :<br/>
		/// Perform the matrix operation `b = a*b`.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// A pointer to matrix `a`.<br/>
		/// <br/>
		/// :<br/>
		/// b ::<br/>
		/// A pointer to matrix `b`.<br/>
		/// <br/>
		/// Since the function uses wrap-around arithmetic, results become<br/>
		/// meaningless if the arguments are very large.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Multiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MatrixMultiply([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* b)
		{
			MatrixMultiplyNative(a, b);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Multiply<br/>
		/// <br/>
		/// :<br/>
		/// Perform the matrix operation `b = a*b`.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// A pointer to matrix `a`.<br/>
		/// <br/>
		/// :<br/>
		/// b ::<br/>
		/// A pointer to matrix `b`.<br/>
		/// <br/>
		/// Since the function uses wrap-around arithmetic, results become<br/>
		/// meaningless if the arguments are very large.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Multiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MatrixMultiply([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* b)
		{
			fixed (FTMatrix* pa = &a)
			{
				MatrixMultiplyNative((FTMatrix*)pa, b);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Multiply<br/>
		/// <br/>
		/// :<br/>
		/// Perform the matrix operation `b = a*b`.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// A pointer to matrix `a`.<br/>
		/// <br/>
		/// :<br/>
		/// b ::<br/>
		/// A pointer to matrix `b`.<br/>
		/// <br/>
		/// Since the function uses wrap-around arithmetic, results become<br/>
		/// meaningless if the arguments are very large.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Multiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MatrixMultiply([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix b)
		{
			fixed (FTMatrix* pb = &b)
			{
				MatrixMultiplyNative(a, (FTMatrix*)pb);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Multiply<br/>
		/// <br/>
		/// :<br/>
		/// Perform the matrix operation `b = a*b`.<br/>
		/// <br/>
		/// :<br/>
		/// a ::<br/>
		/// A pointer to matrix `a`.<br/>
		/// <br/>
		/// :<br/>
		/// b ::<br/>
		/// A pointer to matrix `b`.<br/>
		/// <br/>
		/// Since the function uses wrap-around arithmetic, results become<br/>
		/// meaningless if the arguments are very large.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Multiply")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MatrixMultiply([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix a, [NativeName(NativeNameType.Param, "b")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix b)
		{
			fixed (FTMatrix* pa = &a)
			{
				fixed (FTMatrix* pb = &b)
				{
					MatrixMultiplyNative((FTMatrix*)pa, (FTMatrix*)pb);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Invert<br/>
		/// <br/>
		/// :<br/>
		/// Invert a 2x2 matrix.  Return an error if it can't be inverted.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the target matrix.  Remains untouched in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Invert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError MatrixInvertNative([NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* matrix)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTMatrix*, FTError>)funcTable[56])(matrix);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, FTError>)funcTable[56])((nint)matrix);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Invert<br/>
		/// <br/>
		/// :<br/>
		/// Invert a 2x2 matrix.  Return an error if it can't be inverted.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the target matrix.  Remains untouched in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Invert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError MatrixInvert([NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] FTMatrix* matrix)
		{
			FTError ret = MatrixInvertNative(matrix);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Matrix_Invert<br/>
		/// <br/>
		/// :<br/>
		/// Invert a 2x2 matrix.  Return an error if it can't be inverted.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the target matrix.  Remains untouched in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Matrix_Invert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError MatrixInvert([NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix *")] ref FTMatrix matrix)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				FTError ret = MatrixInvertNative((FTMatrix*)pmatrix);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Decompose<br/>
		/// <br/>
		/// :<br/>
		/// Walk over an outline's structure to decompose it into individual<br/>
		/// segments and Bezier arcs.  This function also emits 'move to'<br/>
		/// operations to indicate the start of new contours in the outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source target.<br/>
		/// func_interface ::<br/>
		/// A table of 'emitters', i.e., function pointers called during<br/>
		/// decomposition to indicate path operations.<br/>
		/// <br/>
		/// :<br/>
		/// user ::<br/>
		/// A typeless pointer that is passed to each emitter during the<br/>
		/// decomposition.  It can be used to store the state during the<br/>
		/// decomposition.<br/>
		/// <br/>
		/// <br/>
		/// Similarly, the function returns success for an empty outline also<br/>
		/// (doing nothing, that is, not calling any emitter); if necessary, you<br/>
		/// should filter this out, too.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Decompose")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineDecomposeNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "func_interface")] [NativeName(NativeNameType.Type, "FT_Outline_Funcs const *")] FTOutlineFuncs* funcInterface, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void *")] void* user)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTOutlineFuncs*, void*, FTError>)funcTable[57])(outline, funcInterface, user);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, nint, nint, FTError>)funcTable[57])((nint)outline, (nint)funcInterface, (nint)user);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Decompose<br/>
		/// <br/>
		/// :<br/>
		/// Walk over an outline's structure to decompose it into individual<br/>
		/// segments and Bezier arcs.  This function also emits 'move to'<br/>
		/// operations to indicate the start of new contours in the outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source target.<br/>
		/// func_interface ::<br/>
		/// A table of 'emitters', i.e., function pointers called during<br/>
		/// decomposition to indicate path operations.<br/>
		/// <br/>
		/// :<br/>
		/// user ::<br/>
		/// A typeless pointer that is passed to each emitter during the<br/>
		/// decomposition.  It can be used to store the state during the<br/>
		/// decomposition.<br/>
		/// <br/>
		/// <br/>
		/// Similarly, the function returns success for an empty outline also<br/>
		/// (doing nothing, that is, not calling any emitter); if necessary, you<br/>
		/// should filter this out, too.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Decompose")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDecompose([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "func_interface")] [NativeName(NativeNameType.Type, "FT_Outline_Funcs const *")] FTOutlineFuncs* funcInterface, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void *")] void* user)
		{
			FTError ret = OutlineDecomposeNative(outline, funcInterface, user);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Decompose<br/>
		/// <br/>
		/// :<br/>
		/// Walk over an outline's structure to decompose it into individual<br/>
		/// segments and Bezier arcs.  This function also emits 'move to'<br/>
		/// operations to indicate the start of new contours in the outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source target.<br/>
		/// func_interface ::<br/>
		/// A table of 'emitters', i.e., function pointers called during<br/>
		/// decomposition to indicate path operations.<br/>
		/// <br/>
		/// :<br/>
		/// user ::<br/>
		/// A typeless pointer that is passed to each emitter during the<br/>
		/// decomposition.  It can be used to store the state during the<br/>
		/// decomposition.<br/>
		/// <br/>
		/// <br/>
		/// Similarly, the function returns success for an empty outline also<br/>
		/// (doing nothing, that is, not calling any emitter); if necessary, you<br/>
		/// should filter this out, too.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Decompose")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDecompose([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "func_interface")] [NativeName(NativeNameType.Type, "FT_Outline_Funcs const *")] FTOutlineFuncs* funcInterface, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void *")] void* user)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineDecomposeNative((FTOutline*)poutline, funcInterface, user);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Decompose<br/>
		/// <br/>
		/// :<br/>
		/// Walk over an outline's structure to decompose it into individual<br/>
		/// segments and Bezier arcs.  This function also emits 'move to'<br/>
		/// operations to indicate the start of new contours in the outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source target.<br/>
		/// func_interface ::<br/>
		/// A table of 'emitters', i.e., function pointers called during<br/>
		/// decomposition to indicate path operations.<br/>
		/// <br/>
		/// :<br/>
		/// user ::<br/>
		/// A typeless pointer that is passed to each emitter during the<br/>
		/// decomposition.  It can be used to store the state during the<br/>
		/// decomposition.<br/>
		/// <br/>
		/// <br/>
		/// Similarly, the function returns success for an empty outline also<br/>
		/// (doing nothing, that is, not calling any emitter); if necessary, you<br/>
		/// should filter this out, too.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Decompose")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDecompose([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "func_interface")] [NativeName(NativeNameType.Type, "FT_Outline_Funcs const *")] ref FTOutlineFuncs funcInterface, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void *")] void* user)
		{
			fixed (FTOutlineFuncs* pfuncInterface = &funcInterface)
			{
				FTError ret = OutlineDecomposeNative(outline, (FTOutlineFuncs*)pfuncInterface, user);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Decompose<br/>
		/// <br/>
		/// :<br/>
		/// Walk over an outline's structure to decompose it into individual<br/>
		/// segments and Bezier arcs.  This function also emits 'move to'<br/>
		/// operations to indicate the start of new contours in the outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source target.<br/>
		/// func_interface ::<br/>
		/// A table of 'emitters', i.e., function pointers called during<br/>
		/// decomposition to indicate path operations.<br/>
		/// <br/>
		/// :<br/>
		/// user ::<br/>
		/// A typeless pointer that is passed to each emitter during the<br/>
		/// decomposition.  It can be used to store the state during the<br/>
		/// decomposition.<br/>
		/// <br/>
		/// <br/>
		/// Similarly, the function returns success for an empty outline also<br/>
		/// (doing nothing, that is, not calling any emitter); if necessary, you<br/>
		/// should filter this out, too.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Decompose")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDecompose([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "func_interface")] [NativeName(NativeNameType.Type, "FT_Outline_Funcs const *")] ref FTOutlineFuncs funcInterface, [NativeName(NativeNameType.Param, "user")] [NativeName(NativeNameType.Type, "void *")] void* user)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTOutlineFuncs* pfuncInterface = &funcInterface)
				{
					FTError ret = OutlineDecomposeNative((FTOutline*)poutline, (FTOutlineFuncs*)pfuncInterface, user);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new outline of a given size.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library object from where the outline is allocated.<br/>
		/// Note however that the new outline will **not** necessarily be<br/>
		/// **freed**, when destroying the library, by <br/>
		/// _Done_FreeType.<br/>
		/// numPoints ::<br/>
		/// The maximum number of points within the outline.  Must be smaller<br/>
		/// than or equal to 0xFFFF (65535).<br/>
		/// numContours ::<br/>
		/// The maximum number of contours within the outline.  This value must<br/>
		/// be in the range 0 to `numPoints`.<br/>
		/// <br/>
		/// :<br/>
		/// anoutline ::<br/>
		/// A handle to the new outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineNewNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* anoutline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, uint, int, FTOutline*, FTError>)funcTable[58])(library, numPoints, numContours, anoutline);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, uint, int, nint, FTError>)funcTable[58])(library, numPoints, numContours, (nint)anoutline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new outline of a given size.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library object from where the outline is allocated.<br/>
		/// Note however that the new outline will **not** necessarily be<br/>
		/// **freed**, when destroying the library, by <br/>
		/// _Done_FreeType.<br/>
		/// numPoints ::<br/>
		/// The maximum number of points within the outline.  Must be smaller<br/>
		/// than or equal to 0xFFFF (65535).<br/>
		/// numContours ::<br/>
		/// The maximum number of contours within the outline.  This value must<br/>
		/// be in the range 0 to `numPoints`.<br/>
		/// <br/>
		/// :<br/>
		/// anoutline ::<br/>
		/// A handle to the new outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineNew([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* anoutline)
		{
			FTError ret = OutlineNewNative(library, numPoints, numContours, anoutline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new outline of a given size.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to the library object from where the outline is allocated.<br/>
		/// Note however that the new outline will **not** necessarily be<br/>
		/// **freed**, when destroying the library, by <br/>
		/// _Done_FreeType.<br/>
		/// numPoints ::<br/>
		/// The maximum number of points within the outline.  Must be smaller<br/>
		/// than or equal to 0xFFFF (65535).<br/>
		/// numContours ::<br/>
		/// The maximum number of contours within the outline.  This value must<br/>
		/// be in the range 0 to `numPoints`.<br/>
		/// <br/>
		/// :<br/>
		/// anoutline ::<br/>
		/// A handle to the new outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineNew([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "numPoints")] [NativeName(NativeNameType.Type, "FT_UInt")] uint numPoints, [NativeName(NativeNameType.Param, "numContours")] [NativeName(NativeNameType.Type, "FT_Int")] int numContours, [NativeName(NativeNameType.Param, "anoutline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline anoutline)
		{
			fixed (FTOutline* panoutline = &anoutline)
			{
				FTError ret = OutlineNewNative(library, numPoints, numContours, (FTOutline*)panoutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy an outline created with <br/>
		/// _Outline_New.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle of the library object used to allocate the outline.<br/>
		/// outline ::<br/>
		/// A pointer to the outline object to be discarded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineDoneNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTOutline*, FTError>)funcTable[59])(library, outline);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, FTError>)funcTable[59])(library, (nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy an outline created with <br/>
		/// _Outline_New.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle of the library object used to allocate the outline.<br/>
		/// outline ::<br/>
		/// A pointer to the outline object to be discarded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDone([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FTError ret = OutlineDoneNative(library, outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy an outline created with <br/>
		/// _Outline_New.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle of the library object used to allocate the outline.<br/>
		/// outline ::<br/>
		/// A pointer to the outline object to be discarded.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineDone([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineDoneNative(library, (FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Check<br/>
		/// <br/>
		/// :<br/>
		/// Check the contents of an outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to a source outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Check")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineCheckNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTError>)funcTable[60])(outline);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, FTError>)funcTable[60])((nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Check<br/>
		/// <br/>
		/// :<br/>
		/// Check the contents of an outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to a source outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Check")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineCheck([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FTError ret = OutlineCheckNative(outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Check<br/>
		/// <br/>
		/// :<br/>
		/// Check the contents of an outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to a source outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Check")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineCheck([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineCheckNative((FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return an outline's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The outline's control box.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OutlineGetCBoxNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* acbox)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTOutline*, FTBBox*, void>)funcTable[61])(outline, acbox);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[61])((nint)outline, (nint)acbox);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return an outline's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The outline's control box.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineGetCBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* acbox)
		{
			OutlineGetCBoxNative(outline, acbox);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return an outline's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The outline's control box.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineGetCBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* acbox)
		{
			fixed (FTOutline* poutline = &outline)
			{
				OutlineGetCBoxNative((FTOutline*)poutline, acbox);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return an outline's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The outline's control box.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineGetCBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] ref FTBBox acbox)
		{
			fixed (FTBBox* pacbox = &acbox)
			{
				OutlineGetCBoxNative(outline, (FTBBox*)pacbox);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_CBox<br/>
		/// <br/>
		/// :<br/>
		/// Return an outline's 'control box'.  The control box encloses all the<br/>
		/// outline's points, including Bezier control points.  Though it<br/>
		/// coincides with the exact bounding box for most glyphs, it can be<br/>
		/// slightly larger in some situations (like when rotating an outline that<br/>
		/// contains Bezier outside arcs).<br/>
		/// Computing the control box is very fast, while getting the bounding box<br/>
		/// can take much more time as it needs to walk over all segments and arcs<br/>
		/// in the outline.  To get the latter, you can use the 'ftbbox'<br/>
		/// component, which is dedicated to this single task.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// acbox ::<br/>
		/// The outline's control box.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_CBox")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineGetCBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "acbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] ref FTBBox acbox)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTBBox* pacbox = &acbox)
				{
					OutlineGetCBoxNative((FTOutline*)poutline, (FTBBox*)pacbox);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Translate<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple translation to the points of an outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// xOffset ::<br/>
		/// The horizontal offset.<br/>
		/// yOffset ::<br/>
		/// The vertical offset.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Translate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OutlineTranslateNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "xOffset")] [NativeName(NativeNameType.Type, "FT_Pos")] int xOffset, [NativeName(NativeNameType.Param, "yOffset")] [NativeName(NativeNameType.Type, "FT_Pos")] int yOffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTOutline*, int, int, void>)funcTable[62])(outline, xOffset, yOffset);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[62])((nint)outline, xOffset, yOffset);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Translate<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple translation to the points of an outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// xOffset ::<br/>
		/// The horizontal offset.<br/>
		/// yOffset ::<br/>
		/// The vertical offset.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Translate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineTranslate([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "xOffset")] [NativeName(NativeNameType.Type, "FT_Pos")] int xOffset, [NativeName(NativeNameType.Param, "yOffset")] [NativeName(NativeNameType.Type, "FT_Pos")] int yOffset)
		{
			OutlineTranslateNative(outline, xOffset, yOffset);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Translate<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple translation to the points of an outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// xOffset ::<br/>
		/// The horizontal offset.<br/>
		/// yOffset ::<br/>
		/// The vertical offset.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Translate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineTranslate([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "xOffset")] [NativeName(NativeNameType.Type, "FT_Pos")] int xOffset, [NativeName(NativeNameType.Param, "yOffset")] [NativeName(NativeNameType.Type, "FT_Pos")] int yOffset)
		{
			fixed (FTOutline* poutline = &outline)
			{
				OutlineTranslateNative((FTOutline*)poutline, xOffset, yOffset);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy an outline into another one.  Both objects must have the same<br/>
		/// sizes (number of points <br/>
		/// &<br/>
		/// number of contours) when this function is<br/>
		/// called.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineCopyNative([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTOutline*, FTError>)funcTable[63])(source, target);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, nint, FTError>)funcTable[63])((nint)source, (nint)target);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy an outline into another one.  Both objects must have the same<br/>
		/// sizes (number of points <br/>
		/// &<br/>
		/// number of contours) when this function is<br/>
		/// called.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineCopy([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* target)
		{
			FTError ret = OutlineCopyNative(source, target);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy an outline into another one.  Both objects must have the same<br/>
		/// sizes (number of points <br/>
		/// &<br/>
		/// number of contours) when this function is<br/>
		/// called.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineCopy([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* target)
		{
			fixed (FTOutline* psource = &source)
			{
				FTError ret = OutlineCopyNative((FTOutline*)psource, target);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy an outline into another one.  Both objects must have the same<br/>
		/// sizes (number of points <br/>
		/// &<br/>
		/// number of contours) when this function is<br/>
		/// called.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineCopy([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline target)
		{
			fixed (FTOutline* ptarget = &target)
			{
				FTError ret = OutlineCopyNative(source, (FTOutline*)ptarget);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy an outline into another one.  Both objects must have the same<br/>
		/// sizes (number of points <br/>
		/// &<br/>
		/// number of contours) when this function is<br/>
		/// called.<br/>
		/// <br/>
		/// :<br/>
		/// source ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineCopy([NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline target)
		{
			fixed (FTOutline* psource = &source)
			{
				fixed (FTOutline* ptarget = &target)
				{
					FTError ret = OutlineCopyNative((FTOutline*)psource, (FTOutline*)ptarget);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple 2x2 matrix to all of an outline's points.  Useful for<br/>
		/// applying rotations, slanting, flipping, etc.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OutlineTransformNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTOutline*, FTMatrix*, void>)funcTable[64])(outline, matrix);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[64])((nint)outline, (nint)matrix);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple 2x2 matrix to all of an outline's points.  Useful for<br/>
		/// applying rotations, slanting, flipping, etc.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineTransform([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix)
		{
			OutlineTransformNative(outline, matrix);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple 2x2 matrix to all of an outline's points.  Useful for<br/>
		/// applying rotations, slanting, flipping, etc.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineTransform([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] FTMatrix* matrix)
		{
			fixed (FTOutline* poutline = &outline)
			{
				OutlineTransformNative((FTOutline*)poutline, matrix);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple 2x2 matrix to all of an outline's points.  Useful for<br/>
		/// applying rotations, slanting, flipping, etc.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineTransform([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] FTOutline* outline, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix matrix)
		{
			fixed (FTMatrix* pmatrix = &matrix)
			{
				OutlineTransformNative(outline, (FTMatrix*)pmatrix);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Transform<br/>
		/// <br/>
		/// :<br/>
		/// Apply a simple 2x2 matrix to all of an outline's points.  Useful for<br/>
		/// applying rotations, slanting, flipping, etc.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// matrix ::<br/>
		/// A pointer to the transformation matrix.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Transform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineTransform([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline const *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "matrix")] [NativeName(NativeNameType.Type, "FT_Matrix const *")] ref FTMatrix matrix)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTMatrix* pmatrix = &matrix)
				{
					OutlineTransformNative((FTOutline*)poutline, (FTMatrix*)pmatrix);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden an outline.  The new outline will be at most 4~times<br/>
		/// `strength` pixels wider and higher.  You may think of the left and<br/>
		/// bottom borders as unchanged.<br/>
		/// Negative `strength` values to reduce the outline thickness are<br/>
		/// possible also.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// :<br/>
		/// strength ::<br/>
		/// How strong the glyph is emboldened.  Expressed in 26.6 pixel format.<br/>
		/// <br/>
		/// <br/>
		/// If you need 'better' metrics values you should call<br/>
		/// <br/>
		/// _Outline_Get_CBox or <br/>
		/// _Outline_Get_BBox.<br/>
		/// To get meaningful results, font scaling values must be set with<br/>
		/// functions like <br/>
		/// _Set_Char_Size before calling FT_Render_Glyph.<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Load_Glyph( face, index, FT_LOAD_DEFAULT );<br/>
		/// if ( face->glyph->format == FT_GLYPH_FORMAT_OUTLINE )<br/>
		/// FT_Outline_Embolden( <br/>
		/// &face<br/>
		/// ->glyph->outline, strength );<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineEmboldenNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "FT_Pos")] int strength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, int, FTError>)funcTable[65])(outline, strength);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, int, FTError>)funcTable[65])((nint)outline, strength);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden an outline.  The new outline will be at most 4~times<br/>
		/// `strength` pixels wider and higher.  You may think of the left and<br/>
		/// bottom borders as unchanged.<br/>
		/// Negative `strength` values to reduce the outline thickness are<br/>
		/// possible also.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// :<br/>
		/// strength ::<br/>
		/// How strong the glyph is emboldened.  Expressed in 26.6 pixel format.<br/>
		/// <br/>
		/// <br/>
		/// If you need 'better' metrics values you should call<br/>
		/// <br/>
		/// _Outline_Get_CBox or <br/>
		/// _Outline_Get_BBox.<br/>
		/// To get meaningful results, font scaling values must be set with<br/>
		/// functions like <br/>
		/// _Set_Char_Size before calling FT_Render_Glyph.<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Load_Glyph( face, index, FT_LOAD_DEFAULT );<br/>
		/// if ( face->glyph->format == FT_GLYPH_FORMAT_OUTLINE )<br/>
		/// FT_Outline_Embolden( <br/>
		/// &face<br/>
		/// ->glyph->outline, strength );<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineEmbolden([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "FT_Pos")] int strength)
		{
			FTError ret = OutlineEmboldenNative(outline, strength);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden an outline.  The new outline will be at most 4~times<br/>
		/// `strength` pixels wider and higher.  You may think of the left and<br/>
		/// bottom borders as unchanged.<br/>
		/// Negative `strength` values to reduce the outline thickness are<br/>
		/// possible also.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to the target outline.<br/>
		/// <br/>
		/// :<br/>
		/// strength ::<br/>
		/// How strong the glyph is emboldened.  Expressed in 26.6 pixel format.<br/>
		/// <br/>
		/// <br/>
		/// If you need 'better' metrics values you should call<br/>
		/// <br/>
		/// _Outline_Get_CBox or <br/>
		/// _Outline_Get_BBox.<br/>
		/// To get meaningful results, font scaling values must be set with<br/>
		/// functions like <br/>
		/// _Set_Char_Size before calling FT_Render_Glyph.<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Load_Glyph( face, index, FT_LOAD_DEFAULT );<br/>
		/// if ( face->glyph->format == FT_GLYPH_FORMAT_OUTLINE )<br/>
		/// FT_Outline_Embolden( <br/>
		/// &face<br/>
		/// ->glyph->outline, strength );<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineEmbolden([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "strength")] [NativeName(NativeNameType.Type, "FT_Pos")] int strength)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineEmboldenNative((FTOutline*)poutline, strength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_EmboldenXY<br/>
		/// <br/>
		/// :<br/>
		/// Embolden an outline.  The new outline will be `xstrength` pixels wider<br/>
		/// and `ystrength` pixels higher.  Otherwise, it is similar to<br/>
		/// <br/>
		/// _Outline_Embolden, which uses the same strength in both directions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_EmboldenXY")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineEmboldenXYNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "xstrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xstrength, [NativeName(NativeNameType.Param, "ystrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int ystrength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, int, int, FTError>)funcTable[66])(outline, xstrength, ystrength);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, int, int, FTError>)funcTable[66])((nint)outline, xstrength, ystrength);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_EmboldenXY<br/>
		/// <br/>
		/// :<br/>
		/// Embolden an outline.  The new outline will be `xstrength` pixels wider<br/>
		/// and `ystrength` pixels higher.  Otherwise, it is similar to<br/>
		/// <br/>
		/// _Outline_Embolden, which uses the same strength in both directions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_EmboldenXY")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineEmboldenXY([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "xstrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xstrength, [NativeName(NativeNameType.Param, "ystrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int ystrength)
		{
			FTError ret = OutlineEmboldenXYNative(outline, xstrength, ystrength);
			return ret;
		}
	}
}
