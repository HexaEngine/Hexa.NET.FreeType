// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public unsafe partial class FreeType
	{

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_EmboldenXY<br/>
		/// <br/>
		/// :<br/>
		/// Embolden an outline.  The new outline will be `xstrength` pixels wider<br/>
		/// and `ystrength` pixels higher.  Otherwise, it is similar to<br/>
		/// <br/>
		/// _Outline_Embolden, which uses the same strength in both directions.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_EmboldenXY")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineEmboldenXY([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "xstrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xstrength, [NativeName(NativeNameType.Param, "ystrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int ystrength)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineEmboldenXYNative((FTOutline*)poutline, xstrength, ystrength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Reverse<br/>
		/// <br/>
		/// :<br/>
		/// Reverse the drawing direction of an outline.  This is used to ensure<br/>
		/// consistent fill conventions for mirrored glyphs.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// It shouldn't be used by a normal client application, unless it knows<br/>
		/// what it is doing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Reverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OutlineReverseNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTOutline*, void>)funcTable[67])(outline);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[67])((nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Reverse<br/>
		/// <br/>
		/// :<br/>
		/// Reverse the drawing direction of an outline.  This is used to ensure<br/>
		/// consistent fill conventions for mirrored glyphs.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// It shouldn't be used by a normal client application, unless it knows<br/>
		/// what it is doing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Reverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineReverse([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			OutlineReverseNative(outline);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Reverse<br/>
		/// <br/>
		/// :<br/>
		/// Reverse the drawing direction of an outline.  This is used to ensure<br/>
		/// consistent fill conventions for mirrored glyphs.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the target outline descriptor.<br/>
		/// <br/>
		/// It shouldn't be used by a normal client application, unless it knows<br/>
		/// what it is doing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Reverse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void OutlineReverse([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				OutlineReverseNative((FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineGetBitmapNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* abitmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTOutline*, FTBitmap*, FTError>)funcTable[68])(library, outline, abitmap);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, nint, FTError>)funcTable[68])(library, (nint)outline, (nint)abitmap);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* abitmap)
		{
			FTError ret = OutlineGetBitmapNative(library, outline, abitmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* abitmap)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineGetBitmapNative(library, (FTOutline*)poutline, abitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap abitmap)
		{
			fixed (FTBitmap* pabitmap = &abitmap)
			{
				FTError ret = OutlineGetBitmapNative(library, outline, (FTBitmap*)pabitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap.  The outline's image is simply<br/>
		/// OR-ed to the target bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the target bitmap descriptor.<br/>
		/// <br/>
		/// <br/>
		/// It will use the raster corresponding to the default glyph format.<br/>
		/// The value of the `num_grays` field in `abitmap` is ignored.  If you<br/>
		/// select the gray-level rasterizer, and you want less than 256 gray<br/>
		/// levels, you have to use <br/>
		/// _Outline_Render directly.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBitmap([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap abitmap)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTBitmap* pabitmap = &abitmap)
				{
					FTError ret = OutlineGetBitmapNative(library, (FTOutline*)poutline, (FTBitmap*)pabitmap);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineRenderNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] FTRasterParams* @params)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTOutline*, FTRasterParams*, FTError>)funcTable[69])(library, outline, @params);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, nint, FTError>)funcTable[69])(library, (nint)outline, (nint)@params);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] FTRasterParams* @params)
		{
			FTError ret = OutlineRenderNative(library, outline, @params);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] FTRasterParams* @params)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineRenderNative(library, (FTOutline*)poutline, @params);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] ref FTRasterParams @params)
		{
			fixed (FTRasterParams* pparams = &@params)
			{
				FTError ret = OutlineRenderNative(library, outline, (FTRasterParams*)pparams);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Render<br/>
		/// <br/>
		/// :<br/>
		/// Render an outline within a bitmap using the current scan-convert.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a FreeType library object.<br/>
		/// outline ::<br/>
		/// A pointer to the source outline descriptor.<br/>
		/// <br/>
		/// :<br/>
		/// params ::<br/>
		/// A pointer to an <br/>
		/// _Raster_Params structure used to describe the<br/>
		/// rendering operation.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Render")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineRender([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "params")] [NativeName(NativeNameType.Type, "FT_Raster_Params *")] ref FTRasterParams @params)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTRasterParams* pparams = &@params)
				{
					FTError ret = OutlineRenderNative(library, (FTOutline*)poutline, (FTRasterParams*)pparams);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Orientation<br/>
		/// <br/>
		/// :<br/>
		/// This function analyzes a glyph outline and tries to compute its fill<br/>
		/// orientation (see <br/>
		/// _Orientation).  This is done by integrating the<br/>
		/// total area covered by the outline. The positive integral corresponds<br/>
		/// to the clockwise orientation and <br/>
		/// _ORIENTATION_POSTSCRIPT is<br/>
		/// returned. The negative integral corresponds to the counter-clockwise<br/>
		/// orientation and <br/>
		/// _ORIENTATION_TRUETYPE is returned.<br/>
		/// Note that this will return <br/>
		/// _ORIENTATION_TRUETYPE for empty<br/>
		/// outlines.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Orientation")]
		[return: NativeName(NativeNameType.Type, "FT_Orientation")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTOrientation OutlineGetOrientationNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTOrientation>)funcTable[70])(outline);
			#else
			return (FTOrientation)((delegate* unmanaged[Cdecl]<nint, FTOrientation>)funcTable[70])((nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Orientation<br/>
		/// <br/>
		/// :<br/>
		/// This function analyzes a glyph outline and tries to compute its fill<br/>
		/// orientation (see <br/>
		/// _Orientation).  This is done by integrating the<br/>
		/// total area covered by the outline. The positive integral corresponds<br/>
		/// to the clockwise orientation and <br/>
		/// _ORIENTATION_POSTSCRIPT is<br/>
		/// returned. The negative integral corresponds to the counter-clockwise<br/>
		/// orientation and <br/>
		/// _ORIENTATION_TRUETYPE is returned.<br/>
		/// Note that this will return <br/>
		/// _ORIENTATION_TRUETYPE for empty<br/>
		/// outlines.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Orientation")]
		[return: NativeName(NativeNameType.Type, "FT_Orientation")]
		public static FTOrientation OutlineGetOrientation([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FTOrientation ret = OutlineGetOrientationNative(outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_Orientation<br/>
		/// <br/>
		/// :<br/>
		/// This function analyzes a glyph outline and tries to compute its fill<br/>
		/// orientation (see <br/>
		/// _Orientation).  This is done by integrating the<br/>
		/// total area covered by the outline. The positive integral corresponds<br/>
		/// to the clockwise orientation and <br/>
		/// _ORIENTATION_POSTSCRIPT is<br/>
		/// returned. The negative integral corresponds to the counter-clockwise<br/>
		/// orientation and <br/>
		/// _ORIENTATION_TRUETYPE is returned.<br/>
		/// Note that this will return <br/>
		/// _ORIENTATION_TRUETYPE for empty<br/>
		/// outlines.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A handle to the source outline.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_Orientation")]
		[return: NativeName(NativeNameType.Type, "FT_Orientation")]
		public static FTOrientation OutlineGetOrientation([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTOrientation ret = OutlineGetOrientationNative((FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Data_Get<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the face's color palette data.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// A pointer to an <br/>
		/// _Palette_Data structure.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError PaletteDataGetNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data *")] FTPaletteData* apalette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, FTPaletteData*, FTError>)funcTable[71])(face, apalette);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, nint, FTError>)funcTable[71])(face, (nint)apalette);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Data_Get<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the face's color palette data.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// A pointer to an <br/>
		/// _Palette_Data structure.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteDataGet([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data *")] FTPaletteData* apalette)
		{
			FTError ret = PaletteDataGetNative(face, apalette);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Data_Get<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the face's color palette data.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// A pointer to an <br/>
		/// _Palette_Data structure.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Data_Get")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteDataGet([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Palette_Data *")] ref FTPaletteData apalette)
		{
			fixed (FTPaletteData* papalette = &apalette)
			{
				FTError ret = PaletteDataGetNative(face, (FTPaletteData*)papalette);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Select<br/>
		/// <br/>
		/// :<br/>
		/// This function has two purposes.<br/>
		/// (1) It activates a palette for rendering color glyphs, and<br/>
		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>
		/// function returns a read-write array, which means that a calling<br/>
		/// application can modify the palette entries on demand.<br/>
		/// A corollary of (2) is that calling the function, then modifying some<br/>
		/// values, then calling the function again with the same arguments resets<br/>
		/// all color entries to the original 'CPAL' values; all user modifications<br/>
		/// are lost.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// palette_index ::<br/>
		/// The palette index.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// An array of color entries for a palette with index `palette_index`,<br/>
		/// having `num_palette_entries` elements (as found in the<br/>
		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>
		/// array gets returned (and no color entries can be modified).<br/>
		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError PaletteSelectNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color * *")] FTColor** apalette)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, ushort, FTColor**, FTError>)funcTable[72])(face, paletteIndex, apalette);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, ushort, nint, FTError>)funcTable[72])(face, paletteIndex, (nint)apalette);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Select<br/>
		/// <br/>
		/// :<br/>
		/// This function has two purposes.<br/>
		/// (1) It activates a palette for rendering color glyphs, and<br/>
		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>
		/// function returns a read-write array, which means that a calling<br/>
		/// application can modify the palette entries on demand.<br/>
		/// A corollary of (2) is that calling the function, then modifying some<br/>
		/// values, then calling the function again with the same arguments resets<br/>
		/// all color entries to the original 'CPAL' values; all user modifications<br/>
		/// are lost.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// palette_index ::<br/>
		/// The palette index.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// An array of color entries for a palette with index `palette_index`,<br/>
		/// having `num_palette_entries` elements (as found in the<br/>
		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>
		/// array gets returned (and no color entries can be modified).<br/>
		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteSelect([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color * *")] FTColor** apalette)
		{
			FTError ret = PaletteSelectNative(face, paletteIndex, apalette);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Select<br/>
		/// <br/>
		/// :<br/>
		/// This function has two purposes.<br/>
		/// (1) It activates a palette for rendering color glyphs, and<br/>
		/// (2) it retrieves all (unmodified) color entries of this palette.  This<br/>
		/// function returns a read-write array, which means that a calling<br/>
		/// application can modify the palette entries on demand.<br/>
		/// A corollary of (2) is that calling the function, then modifying some<br/>
		/// values, then calling the function again with the same arguments resets<br/>
		/// all color entries to the original 'CPAL' values; all user modifications<br/>
		/// are lost.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// palette_index ::<br/>
		/// The palette index.<br/>
		/// <br/>
		/// :<br/>
		/// apalette ::<br/>
		/// An array of color entries for a palette with index `palette_index`,<br/>
		/// having `num_palette_entries` elements (as found in the<br/>
		/// `FT_Palette_Data` structure).  If `apalette` is set to `NULL`, no<br/>
		/// array gets returned (and no color entries can be modified).<br/>
		/// In case the font doesn't support color palettes, `NULL` is returned.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Select")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteSelect([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "palette_index")] [NativeName(NativeNameType.Type, "FT_UShort")] ushort paletteIndex, [NativeName(NativeNameType.Param, "apalette")] [NativeName(NativeNameType.Type, "FT_Color * *")] ref FTColor* apalette)
		{
			fixed (FTColor** papalette = &apalette)
			{
				FTError ret = PaletteSelectNative(face, paletteIndex, (FTColor**)papalette);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Set_Foreground_Color<br/>
		/// <br/>
		/// :<br/>
		/// 'COLR' uses palette index 0xFFFF to indicate a 'text foreground<br/>
		/// color'.  This function sets this value.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// foreground_color ::<br/>
		/// An `FT_Color` structure to define the text foreground color.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Set_Foreground_Color")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError PaletteSetForegroundColorNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "foreground_color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor foregroundColor)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, FTColor, FTError>)funcTable[73])(face, foregroundColor);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, FTColor, FTError>)funcTable[73])(face, foregroundColor);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Palette_Set_Foreground_Color<br/>
		/// <br/>
		/// :<br/>
		/// 'COLR' uses palette index 0xFFFF to indicate a 'text foreground<br/>
		/// color'.  This function sets this value.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// The source face handle.<br/>
		/// foreground_color ::<br/>
		/// An `FT_Color` structure to define the text foreground color.<br/>
		/// <br/>
		/// <br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_COLOR_LAYERS` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Palette_Set_Foreground_Color")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError PaletteSetForegroundColor([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "foreground_color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor foregroundColor)
		{
			FTError ret = PaletteSetForegroundColorNative(face, foregroundColor);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetColorGlyphLayerNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, uint*, uint*, FTLayerIterator*, byte>)funcTable[74])(face, baseGlyph, aglyphIndex, acolorIndex, iterator);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, uint, nint, nint, nint, byte>)funcTable[74])(face, baseGlyph, (nint)aglyphIndex, (nint)acolorIndex, (nint)iterator);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator)
		{
			byte ret = GetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, acolorIndex, iterator);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				byte ret = GetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, acolorIndex, iterator);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator)
		{
			fixed (uint* pacolorIndex = &acolorIndex)
			{
				byte ret = GetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, (uint*)pacolorIndex, iterator);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (uint* pacolorIndex = &acolorIndex)
				{
					byte ret = GetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, (uint*)pacolorIndex, iterator);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] ref FTLayerIterator iterator)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				byte ret = GetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, acolorIndex, (FTLayerIterator*)piterator);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] ref FTLayerIterator iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (FTLayerIterator* piterator = &iterator)
				{
					byte ret = GetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, acolorIndex, (FTLayerIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] ref FTLayerIterator iterator)
		{
			fixed (uint* pacolorIndex = &acolorIndex)
			{
				fixed (FTLayerIterator* piterator = &iterator)
				{
					byte ret = GetColorGlyphLayerNative(face, baseGlyph, aglyphIndex, (uint*)pacolorIndex, (FTLayerIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Layer<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to the 'COLR' table in OpenType fonts to<br/>
		/// iteratively retrieve the colored glyph layers associated with the<br/>
		/// current glyph slot.<br/>
		/// https://docs.microsoft.com/en-us/typography/opentype/spec/colr<br/>
		/// The glyph layer data for a given glyph index, if present, provides an<br/>
		/// alternative, multi-color glyph representation: Instead of rendering<br/>
		/// the outline or bitmap with the given glyph index, glyphs with the<br/>
		/// indices and colors returned by this function are rendered layer by<br/>
		/// layer.<br/>
		/// The returned elements are ordered in the z~direction from bottom to<br/>
		/// top; the 'n'th element should be rendered with the associated palette<br/>
		/// color and blended on top of the already rendered layers (elements 0,<br/>
		/// 1, ..., n-1).<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index the colored glyph layers are associated with.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// An <br/>
		/// _LayerIterator object.  For the first call you should set<br/>
		/// `iterator->p` to `NULL`.  For all following calls, simply use the<br/>
		/// same object again.<br/>
		/// <br/>
		/// :<br/>
		/// aglyph_index ::<br/>
		/// The glyph index of the current layer.<br/>
		/// acolor_index ::<br/>
		/// The color index into the font face's color palette of the current<br/>
		/// layer.  The value 0xFFFF is special; it doesn't reference a palette<br/>
		/// entry but indicates that the text foreground color should be used<br/>
		/// instead (to be set up by the application outside of FreeType).<br/>
		/// The color palette can be retrieved with <br/>
		/// _Palette_Select.<br/>
		/// <br/>
		/// <br/>
		/// Note that <br/>
		/// _Render_Glyph is able to handle colored glyph layers<br/>
		/// automatically if the <br/>
		/// _LOAD_COLOR flag is passed to a previous call<br/>
		/// to <br/>
		/// _Load_Glyph.  [This is an experimental feature.]<br/>
		/// <br/>
		/// ```<br/>
		/// FT_Color*         palette;<br/>
		/// FT_LayerIterator  iterator;<br/>
		/// FT_Bool  have_layers;<br/>
		/// FT_UInt  layer_glyph_index;<br/>
		/// FT_UInt  layer_color_index;<br/>
		/// error = FT_Palette_Select( face, palette_index, <br/>
		/// &palette<br/>
		/// );<br/>
		/// if ( error )<br/>
		/// palette = NULL;<br/>
		/// iterator.p  = NULL;<br/>
		/// have_layers = FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// );<br/>
		/// if ( palette <br/>
		/// &<br/>
		/// &<br/>
		/// have_layers )<br/>
		/// {<br/>
		/// do<br/>
		/// {<br/>
		/// FT_Color  layer_color;<br/>
		/// if ( layer_color_index == 0xFFFF )<br/>
		/// layer_color = text_foreground_color;<br/>
		/// else<br/>
		/// layer_color = palette[layer_color_index];<br/>
		/// // Load and render glyph `layer_glyph_index', then<br/>
		/// // blend resulting pixmap (using color `layer_color')<br/>
		/// // with previously created pixmaps.<br/>
		/// } while ( FT_Get_Color_Glyph_Layer( face,<br/>
		/// glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _glyph_index,<br/>
		/// <br/>
		/// &layer<br/>
		/// _color_index,<br/>
		/// <br/>
		/// &iterator<br/>
		/// ) );<br/>
		/// }<br/>
		/// ```<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Layer")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphLayer([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "aglyph_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint aglyphIndex, [NativeName(NativeNameType.Param, "acolor_index")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint acolorIndex, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] ref FTLayerIterator iterator)
		{
			fixed (uint* paglyphIndex = &aglyphIndex)
			{
				fixed (uint* pacolorIndex = &acolorIndex)
				{
					fixed (FTLayerIterator* piterator = &iterator)
					{
						byte ret = GetColorGlyphLayerNative(face, baseGlyph, (uint*)paglyphIndex, (uint*)pacolorIndex, (FTLayerIterator*)piterator);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Paint<br/>
		/// <br/>
		/// :<br/>
		/// This is the starting point and interface to color gradient<br/>
		/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>
		/// retrieve the paint tables for the directed acyclic graph of a colored<br/>
		/// glyph, given a glyph ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>
		/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>
		/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>
		/// function and specifying a glyph ID, one retrieves the root paint<br/>
		/// table for this glyph ID.<br/>
		/// This function allows control whether an initial root transform is<br/>
		/// returned to configure scaling, transform, and translation correctly<br/>
		/// on the client's graphics context.  The initial root transform is<br/>
		/// computed and returned according to the values configured for <br/>
		/// _Size<br/>
		/// and <br/>
		/// _Set_Transform on the <br/>
		/// _Face object, see below for details<br/>
		/// of the `root_transform` parameter.  This has implications for a<br/>
		/// client 'COLR' v1 implementation: When this function returns an<br/>
		/// initially computed root transform, at the time of executing the<br/>
		/// <br/>
		/// _PaintGlyph operation, the contours should be retrieved using<br/>
		/// <br/>
		/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>
		/// root transform applied to the graphics context will take care of<br/>
		/// correct scaling.<br/>
		/// Alternatively, to allow hinting of contours, at the time of executing<br/>
		/// <br/>
		/// _Load_Glyph, the current graphics context transformation matrix<br/>
		/// can be decomposed into a scaling matrix and a remainder, and<br/>
		/// <br/>
		/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>
		/// Care must then be taken to blit or clip to the graphics context with<br/>
		/// taking this remainder transformation into account.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the root paint table.<br/>
		/// root_transform ::<br/>
		/// Specifies whether an initially computed root is returned by the<br/>
		/// <br/>
		/// _PaintTransform operation to account for the activated size<br/>
		/// (see <br/>
		/// _Activate_Size) and the configured transform and translate<br/>
		/// (see <br/>
		/// _Set_Transform).<br/>
		/// This root transform is returned before nodes of the glyph graph of<br/>
		/// the font are returned.  Subsequent <br/>
		/// _COLR_Paint structures<br/>
		/// contain unscaled and untransformed values.  The inserted root<br/>
		/// transform enables the client application to apply an initial<br/>
		/// transform to its graphics context.  When executing subsequent<br/>
		/// FT_COLR_Paint operations, values from <br/>
		/// _COLR_Paint operations<br/>
		/// will ultimately be correctly scaled because of the root transform<br/>
		/// applied to the graphics context.  Use<br/>
		/// <br/>
		/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>
		/// <br/>
		/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>
		/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>
		/// <br/>
		/// _PaintColrGlyph.  When recursing into <br/>
		/// _PaintColrGlyph and<br/>
		/// painting that inline, no additional root transform is needed as it<br/>
		/// has already been applied to the graphics context at the beginning<br/>
		/// of drawing this glyph.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetColorGlyphPaintNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] FTOpaquePaint* paint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, FTColorRootTransform, FTOpaquePaint*, byte>)funcTable[75])(face, baseGlyph, rootTransform, paint);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, uint, FTColorRootTransform, nint, byte>)funcTable[75])(face, baseGlyph, rootTransform, (nint)paint);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Paint<br/>
		/// <br/>
		/// :<br/>
		/// This is the starting point and interface to color gradient<br/>
		/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>
		/// retrieve the paint tables for the directed acyclic graph of a colored<br/>
		/// glyph, given a glyph ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>
		/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>
		/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>
		/// function and specifying a glyph ID, one retrieves the root paint<br/>
		/// table for this glyph ID.<br/>
		/// This function allows control whether an initial root transform is<br/>
		/// returned to configure scaling, transform, and translation correctly<br/>
		/// on the client's graphics context.  The initial root transform is<br/>
		/// computed and returned according to the values configured for <br/>
		/// _Size<br/>
		/// and <br/>
		/// _Set_Transform on the <br/>
		/// _Face object, see below for details<br/>
		/// of the `root_transform` parameter.  This has implications for a<br/>
		/// client 'COLR' v1 implementation: When this function returns an<br/>
		/// initially computed root transform, at the time of executing the<br/>
		/// <br/>
		/// _PaintGlyph operation, the contours should be retrieved using<br/>
		/// <br/>
		/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>
		/// root transform applied to the graphics context will take care of<br/>
		/// correct scaling.<br/>
		/// Alternatively, to allow hinting of contours, at the time of executing<br/>
		/// <br/>
		/// _Load_Glyph, the current graphics context transformation matrix<br/>
		/// can be decomposed into a scaling matrix and a remainder, and<br/>
		/// <br/>
		/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>
		/// Care must then be taken to blit or clip to the graphics context with<br/>
		/// taking this remainder transformation into account.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the root paint table.<br/>
		/// root_transform ::<br/>
		/// Specifies whether an initially computed root is returned by the<br/>
		/// <br/>
		/// _PaintTransform operation to account for the activated size<br/>
		/// (see <br/>
		/// _Activate_Size) and the configured transform and translate<br/>
		/// (see <br/>
		/// _Set_Transform).<br/>
		/// This root transform is returned before nodes of the glyph graph of<br/>
		/// the font are returned.  Subsequent <br/>
		/// _COLR_Paint structures<br/>
		/// contain unscaled and untransformed values.  The inserted root<br/>
		/// transform enables the client application to apply an initial<br/>
		/// transform to its graphics context.  When executing subsequent<br/>
		/// FT_COLR_Paint operations, values from <br/>
		/// _COLR_Paint operations<br/>
		/// will ultimately be correctly scaled because of the root transform<br/>
		/// applied to the graphics context.  Use<br/>
		/// <br/>
		/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>
		/// <br/>
		/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>
		/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>
		/// <br/>
		/// _PaintColrGlyph.  When recursing into <br/>
		/// _PaintColrGlyph and<br/>
		/// painting that inline, no additional root transform is needed as it<br/>
		/// has already been applied to the graphics context at the beginning<br/>
		/// of drawing this glyph.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] FTOpaquePaint* paint)
		{
			byte ret = GetColorGlyphPaintNative(face, baseGlyph, rootTransform, paint);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_Paint<br/>
		/// <br/>
		/// :<br/>
		/// This is the starting point and interface to color gradient<br/>
		/// information in a 'COLR' v1 table in OpenType fonts to recursively<br/>
		/// retrieve the paint tables for the directed acyclic graph of a colored<br/>
		/// glyph, given a glyph ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// In a 'COLR' v1 font, each color glyph defines a directed acyclic<br/>
		/// graph of nested paint tables, such as `PaintGlyph`, `PaintSolid`,<br/>
		/// `PaintLinearGradient`, `PaintRadialGradient`, and so on.  Using this<br/>
		/// function and specifying a glyph ID, one retrieves the root paint<br/>
		/// table for this glyph ID.<br/>
		/// This function allows control whether an initial root transform is<br/>
		/// returned to configure scaling, transform, and translation correctly<br/>
		/// on the client's graphics context.  The initial root transform is<br/>
		/// computed and returned according to the values configured for <br/>
		/// _Size<br/>
		/// and <br/>
		/// _Set_Transform on the <br/>
		/// _Face object, see below for details<br/>
		/// of the `root_transform` parameter.  This has implications for a<br/>
		/// client 'COLR' v1 implementation: When this function returns an<br/>
		/// initially computed root transform, at the time of executing the<br/>
		/// <br/>
		/// _PaintGlyph operation, the contours should be retrieved using<br/>
		/// <br/>
		/// _Load_Glyph at unscaled, untransformed size.  This is because the<br/>
		/// root transform applied to the graphics context will take care of<br/>
		/// correct scaling.<br/>
		/// Alternatively, to allow hinting of contours, at the time of executing<br/>
		/// <br/>
		/// _Load_Glyph, the current graphics context transformation matrix<br/>
		/// can be decomposed into a scaling matrix and a remainder, and<br/>
		/// <br/>
		/// _Load_Glyph can be used to retrieve the contours at scaled size.<br/>
		/// Care must then be taken to blit or clip to the graphics context with<br/>
		/// taking this remainder transformation into account.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the root paint table.<br/>
		/// root_transform ::<br/>
		/// Specifies whether an initially computed root is returned by the<br/>
		/// <br/>
		/// _PaintTransform operation to account for the activated size<br/>
		/// (see <br/>
		/// _Activate_Size) and the configured transform and translate<br/>
		/// (see <br/>
		/// _Set_Transform).<br/>
		/// This root transform is returned before nodes of the glyph graph of<br/>
		/// the font are returned.  Subsequent <br/>
		/// _COLR_Paint structures<br/>
		/// contain unscaled and untransformed values.  The inserted root<br/>
		/// transform enables the client application to apply an initial<br/>
		/// transform to its graphics context.  When executing subsequent<br/>
		/// FT_COLR_Paint operations, values from <br/>
		/// _COLR_Paint operations<br/>
		/// will ultimately be correctly scaled because of the root transform<br/>
		/// applied to the graphics context.  Use<br/>
		/// <br/>
		/// _COLOR_INCLUDE_ROOT_TRANSFORM to include the root transform, use<br/>
		/// <br/>
		/// _COLOR_NO_ROOT_TRANSFORM to not include it.  The latter may be<br/>
		/// useful when traversing the 'COLR' v1 glyph graph and reaching a<br/>
		/// <br/>
		/// _PaintColrGlyph.  When recursing into <br/>
		/// _PaintColrGlyph and<br/>
		/// painting that inline, no additional root transform is needed as it<br/>
		/// has already been applied to the graphics context at the beginning<br/>
		/// of drawing this glyph.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "root_transform")] [NativeName(NativeNameType.Type, "FT_Color_Root_Transform")] FTColorRootTransform rootTransform, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] ref FTOpaquePaint paint)
		{
			fixed (FTOpaquePaint* ppaint = &paint)
			{
				byte ret = GetColorGlyphPaintNative(face, baseGlyph, rootTransform, (FTOpaquePaint*)ppaint);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_ClipBox<br/>
		/// <br/>
		/// :<br/>
		/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>
		/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>
		/// if one is found.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the clip box.<br/>
		/// <br/>
		/// :<br/>
		/// clip_box ::<br/>
		/// The clip box for the requested `base_glyph` if one is found.  The<br/>
		/// clip box is computed taking scale and transformations configured on<br/>
		/// the <br/>
		/// _Face into account.  <br/>
		/// _ClipBox contains <br/>
		/// _Vector values<br/>
		/// in 26.6 format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetColorGlyphClipBoxNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox *")] FTClipBox* clipBox)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, FTClipBox*, byte>)funcTable[76])(face, baseGlyph, clipBox);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, uint, nint, byte>)funcTable[76])(face, baseGlyph, (nint)clipBox);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_ClipBox<br/>
		/// <br/>
		/// :<br/>
		/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>
		/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>
		/// if one is found.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the clip box.<br/>
		/// <br/>
		/// :<br/>
		/// clip_box ::<br/>
		/// The clip box for the requested `base_glyph` if one is found.  The<br/>
		/// clip box is computed taking scale and transformations configured on<br/>
		/// the <br/>
		/// _Face into account.  <br/>
		/// _ClipBox contains <br/>
		/// _Vector values<br/>
		/// in 26.6 format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphClipBox([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox *")] FTClipBox* clipBox)
		{
			byte ret = GetColorGlyphClipBoxNative(face, baseGlyph, clipBox);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Color_Glyph_ClipBox<br/>
		/// <br/>
		/// :<br/>
		/// Search for a 'COLR' v1 clip box for the specified `base_glyph` and<br/>
		/// fill the `clip_box` parameter with the 'COLR' v1 'ClipBox' information<br/>
		/// if one is found.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// base_glyph ::<br/>
		/// The glyph index for which to retrieve the clip box.<br/>
		/// <br/>
		/// :<br/>
		/// clip_box ::<br/>
		/// The clip box for the requested `base_glyph` if one is found.  The<br/>
		/// clip box is computed taking scale and transformations configured on<br/>
		/// the <br/>
		/// _Face into account.  <br/>
		/// _ClipBox contains <br/>
		/// _Vector values<br/>
		/// in 26.6 format.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Color_Glyph_ClipBox")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorGlyphClipBox([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "base_glyph")] [NativeName(NativeNameType.Type, "FT_UInt")] uint baseGlyph, [NativeName(NativeNameType.Param, "clip_box")] [NativeName(NativeNameType.Type, "FT_ClipBox *")] ref FTClipBox clipBox)
		{
			fixed (FTClipBox* pclipBox = &clipBox)
			{
				byte ret = GetColorGlyphClipBoxNative(face, baseGlyph, (FTClipBox*)pclipBox);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint_Layers<br/>
		/// <br/>
		/// :<br/>
		/// Access the layers of a `PaintColrLayers` table.<br/>
		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>
		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>
		/// layers of the `PaintColrLayers` table.<br/>
		/// The <br/>
		/// _PaintColrLayers object contains an <br/>
		/// _LayerIterator, which<br/>
		/// is used here to iterate over the layers.  Each layer is returned as<br/>
		/// an <br/>
		/// _OpaquePaint object, which then can be used with <br/>
		/// _Get_Paint<br/>
		/// to retrieve the actual paint object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The <br/>
		/// _LayerIterator from an <br/>
		/// _PaintColrLayers object, for which<br/>
		/// the layers are to be retrieved.  The internal state of the iterator<br/>
		/// is incremented after one call to this function for retrieving one<br/>
		/// layer.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetPaintLayersNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] FTOpaquePaint* paint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, FTLayerIterator*, FTOpaquePaint*, byte>)funcTable[77])(face, iterator, paint);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, nint, nint, byte>)funcTable[77])(face, (nint)iterator, (nint)paint);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint_Layers<br/>
		/// <br/>
		/// :<br/>
		/// Access the layers of a `PaintColrLayers` table.<br/>
		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>
		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>
		/// layers of the `PaintColrLayers` table.<br/>
		/// The <br/>
		/// _PaintColrLayers object contains an <br/>
		/// _LayerIterator, which<br/>
		/// is used here to iterate over the layers.  Each layer is returned as<br/>
		/// an <br/>
		/// _OpaquePaint object, which then can be used with <br/>
		/// _Get_Paint<br/>
		/// to retrieve the actual paint object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The <br/>
		/// _LayerIterator from an <br/>
		/// _PaintColrLayers object, for which<br/>
		/// the layers are to be retrieved.  The internal state of the iterator<br/>
		/// is incremented after one call to this function for retrieving one<br/>
		/// layer.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] FTOpaquePaint* paint)
		{
			byte ret = GetPaintLayersNative(face, iterator, paint);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint_Layers<br/>
		/// <br/>
		/// :<br/>
		/// Access the layers of a `PaintColrLayers` table.<br/>
		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>
		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>
		/// layers of the `PaintColrLayers` table.<br/>
		/// The <br/>
		/// _PaintColrLayers object contains an <br/>
		/// _LayerIterator, which<br/>
		/// is used here to iterate over the layers.  Each layer is returned as<br/>
		/// an <br/>
		/// _OpaquePaint object, which then can be used with <br/>
		/// _Get_Paint<br/>
		/// to retrieve the actual paint object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The <br/>
		/// _LayerIterator from an <br/>
		/// _PaintColrLayers object, for which<br/>
		/// the layers are to be retrieved.  The internal state of the iterator<br/>
		/// is incremented after one call to this function for retrieving one<br/>
		/// layer.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] ref FTLayerIterator iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] FTOpaquePaint* paint)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				byte ret = GetPaintLayersNative(face, (FTLayerIterator*)piterator, paint);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint_Layers<br/>
		/// <br/>
		/// :<br/>
		/// Access the layers of a `PaintColrLayers` table.<br/>
		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>
		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>
		/// layers of the `PaintColrLayers` table.<br/>
		/// The <br/>
		/// _PaintColrLayers object contains an <br/>
		/// _LayerIterator, which<br/>
		/// is used here to iterate over the layers.  Each layer is returned as<br/>
		/// an <br/>
		/// _OpaquePaint object, which then can be used with <br/>
		/// _Get_Paint<br/>
		/// to retrieve the actual paint object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The <br/>
		/// _LayerIterator from an <br/>
		/// _PaintColrLayers object, for which<br/>
		/// the layers are to be retrieved.  The internal state of the iterator<br/>
		/// is incremented after one call to this function for retrieving one<br/>
		/// layer.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] FTLayerIterator* iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] ref FTOpaquePaint paint)
		{
			fixed (FTOpaquePaint* ppaint = &paint)
			{
				byte ret = GetPaintLayersNative(face, iterator, (FTOpaquePaint*)ppaint);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint_Layers<br/>
		/// <br/>
		/// :<br/>
		/// Access the layers of a `PaintColrLayers` table.<br/>
		/// If the root paint of a color glyph, or a nested paint of a 'COLR'<br/>
		/// glyph is a `PaintColrLayers` table, this function retrieves the<br/>
		/// layers of the `PaintColrLayers` table.<br/>
		/// The <br/>
		/// _PaintColrLayers object contains an <br/>
		/// _LayerIterator, which<br/>
		/// is used here to iterate over the layers.  Each layer is returned as<br/>
		/// an <br/>
		/// _OpaquePaint object, which then can be used with <br/>
		/// _Get_Paint<br/>
		/// to retrieve the actual paint object.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The <br/>
		/// _LayerIterator from an <br/>
		/// _PaintColrLayers object, for which<br/>
		/// the layers are to be retrieved.  The internal state of the iterator<br/>
		/// is incremented after one call to this function for retrieving one<br/>
		/// layer.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The <br/>
		/// _OpaquePaint object that references the actual paint table.<br/>
		/// The respective actual <br/>
		/// _COLR_Paint object is retrieved via<br/>
		/// <br/>
		/// _Get_Paint.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint_Layers")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaintLayers([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_LayerIterator *")] ref FTLayerIterator iterator, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint *")] ref FTOpaquePaint paint)
		{
			fixed (FTLayerIterator* piterator = &iterator)
			{
				fixed (FTOpaquePaint* ppaint = &paint)
				{
					byte ret = GetPaintLayersNative(face, (FTLayerIterator*)piterator, (FTOpaquePaint*)ppaint);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Colorline_Stops<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to color gradient information in a 'COLR' v1<br/>
		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>
		/// solid fill information for colored glyph layers for a specified glyph<br/>
		/// ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The retrieved <br/>
		/// _ColorStopIterator, configured on an <br/>
		/// _ColorLine,<br/>
		/// which in turn got retrieved via paint information in<br/>
		/// <br/>
		/// _PaintLinearGradient or <br/>
		/// _PaintRadialGradient.<br/>
		/// <br/>
		/// :<br/>
		/// color_stop ::<br/>
		/// Color index and alpha value for the retrieved color stop.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetColorlineStopsNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop *")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator *")] FTColorStopIterator* iterator)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, FTColorStop*, FTColorStopIterator*, byte>)funcTable[78])(face, colorStop, iterator);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, nint, nint, byte>)funcTable[78])(face, (nint)colorStop, (nint)iterator);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Colorline_Stops<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to color gradient information in a 'COLR' v1<br/>
		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>
		/// solid fill information for colored glyph layers for a specified glyph<br/>
		/// ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The retrieved <br/>
		/// _ColorStopIterator, configured on an <br/>
		/// _ColorLine,<br/>
		/// which in turn got retrieved via paint information in<br/>
		/// <br/>
		/// _PaintLinearGradient or <br/>
		/// _PaintRadialGradient.<br/>
		/// <br/>
		/// :<br/>
		/// color_stop ::<br/>
		/// Color index and alpha value for the retrieved color stop.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop *")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator *")] FTColorStopIterator* iterator)
		{
			byte ret = GetColorlineStopsNative(face, colorStop, iterator);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Colorline_Stops<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to color gradient information in a 'COLR' v1<br/>
		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>
		/// solid fill information for colored glyph layers for a specified glyph<br/>
		/// ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The retrieved <br/>
		/// _ColorStopIterator, configured on an <br/>
		/// _ColorLine,<br/>
		/// which in turn got retrieved via paint information in<br/>
		/// <br/>
		/// _PaintLinearGradient or <br/>
		/// _PaintRadialGradient.<br/>
		/// <br/>
		/// :<br/>
		/// color_stop ::<br/>
		/// Color index and alpha value for the retrieved color stop.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop *")] ref FTColorStop colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator *")] FTColorStopIterator* iterator)
		{
			fixed (FTColorStop* pcolorStop = &colorStop)
			{
				byte ret = GetColorlineStopsNative(face, (FTColorStop*)pcolorStop, iterator);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Colorline_Stops<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to color gradient information in a 'COLR' v1<br/>
		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>
		/// solid fill information for colored glyph layers for a specified glyph<br/>
		/// ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The retrieved <br/>
		/// _ColorStopIterator, configured on an <br/>
		/// _ColorLine,<br/>
		/// which in turn got retrieved via paint information in<br/>
		/// <br/>
		/// _PaintLinearGradient or <br/>
		/// _PaintRadialGradient.<br/>
		/// <br/>
		/// :<br/>
		/// color_stop ::<br/>
		/// Color index and alpha value for the retrieved color stop.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop *")] FTColorStop* colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator *")] ref FTColorStopIterator iterator)
		{
			fixed (FTColorStopIterator* piterator = &iterator)
			{
				byte ret = GetColorlineStopsNative(face, colorStop, (FTColorStopIterator*)piterator);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Colorline_Stops<br/>
		/// <br/>
		/// :<br/>
		/// This is an interface to color gradient information in a 'COLR' v1<br/>
		/// table in OpenType fonts to iteratively retrieve the gradient and<br/>
		/// solid fill information for colored glyph layers for a specified glyph<br/>
		/// ID.<br/>
		/// https://github.com/googlefonts/colr-gradients-spec<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// <br/>
		/// :<br/>
		/// iterator ::<br/>
		/// The retrieved <br/>
		/// _ColorStopIterator, configured on an <br/>
		/// _ColorLine,<br/>
		/// which in turn got retrieved via paint information in<br/>
		/// <br/>
		/// _PaintLinearGradient or <br/>
		/// _PaintRadialGradient.<br/>
		/// <br/>
		/// :<br/>
		/// color_stop ::<br/>
		/// Color index and alpha value for the retrieved color stop.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Colorline_Stops")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetColorlineStops([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "color_stop")] [NativeName(NativeNameType.Type, "FT_ColorStop *")] ref FTColorStop colorStop, [NativeName(NativeNameType.Param, "iterator")] [NativeName(NativeNameType.Type, "FT_ColorStopIterator *")] ref FTColorStopIterator iterator)
		{
			fixed (FTColorStop* pcolorStop = &colorStop)
			{
				fixed (FTColorStopIterator* piterator = &iterator)
				{
					byte ret = GetColorlineStopsNative(face, (FTColorStop*)pcolorStop, (FTColorStopIterator*)piterator);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint<br/>
		/// <br/>
		/// :<br/>
		/// Access the details of a paint using an <br/>
		/// _OpaquePaint opaque paint<br/>
		/// object, which internally stores the offset to the respective `Paint`<br/>
		/// object in the 'COLR' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// opaque_paint ::<br/>
		/// The opaque paint object for which the underlying <br/>
		/// _COLR_Paint<br/>
		/// data is to be retrieved.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The specific <br/>
		/// _COLR_Paint object containing information coming<br/>
		/// from one of the font's `Paint*` tables.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte GetPaintNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint *")] FTCOLRPaint* paint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, FTOpaquePaint, FTCOLRPaint*, byte>)funcTable[79])(face, opaquePaint, paint);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<FTFace, FTOpaquePaint, nint, byte>)funcTable[79])(face, opaquePaint, (nint)paint);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint<br/>
		/// <br/>
		/// :<br/>
		/// Access the details of a paint using an <br/>
		/// _OpaquePaint opaque paint<br/>
		/// object, which internally stores the offset to the respective `Paint`<br/>
		/// object in the 'COLR' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// opaque_paint ::<br/>
		/// The opaque paint object for which the underlying <br/>
		/// _COLR_Paint<br/>
		/// data is to be retrieved.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The specific <br/>
		/// _COLR_Paint object containing information coming<br/>
		/// from one of the font's `Paint*` tables.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint *")] FTCOLRPaint* paint)
		{
			byte ret = GetPaintNative(face, opaquePaint, paint);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Paint<br/>
		/// <br/>
		/// :<br/>
		/// Access the details of a paint using an <br/>
		/// _OpaquePaint opaque paint<br/>
		/// object, which internally stores the offset to the respective `Paint`<br/>
		/// object in the 'COLR' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the parent face object.<br/>
		/// opaque_paint ::<br/>
		/// The opaque paint object for which the underlying <br/>
		/// _COLR_Paint<br/>
		/// data is to be retrieved.<br/>
		/// <br/>
		/// :<br/>
		/// paint ::<br/>
		/// The specific <br/>
		/// _COLR_Paint object containing information coming<br/>
		/// from one of the font's `Paint*` tables.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Paint")]
		[return: NativeName(NativeNameType.Type, "FT_Bool")]
		public static byte GetPaint([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "opaque_paint")] [NativeName(NativeNameType.Type, "FT_OpaquePaint")] FTOpaquePaint opaquePaint, [NativeName(NativeNameType.Param, "paint")] [NativeName(NativeNameType.Type, "FT_COLR_Paint *")] ref FTCOLRPaint paint)
		{
			fixed (FTCOLRPaint* ppaint = &paint)
			{
				byte ret = GetPaintNative(face, opaquePaint, (FTCOLRPaint*)ppaint);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Init<br/>
		/// <br/>
		/// :<br/>
		/// Initialize a pointer to an <br/>
		/// _Bitmap structure.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the bitmap structure.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BitmapInitNative([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* abitmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTBitmap*, void>)funcTable[80])(abitmap);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[80])((nint)abitmap);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Init<br/>
		/// <br/>
		/// :<br/>
		/// Initialize a pointer to an <br/>
		/// _Bitmap structure.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the bitmap structure.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BitmapInit([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* abitmap)
		{
			BitmapInitNative(abitmap);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Init<br/>
		/// <br/>
		/// :<br/>
		/// Initialize a pointer to an <br/>
		/// _Bitmap structure.<br/>
		/// <br/>
		/// :<br/>
		/// abitmap ::<br/>
		/// A pointer to the bitmap structure.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Init")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BitmapInit([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap abitmap)
		{
			fixed (FTBitmap* pabitmap = &abitmap)
			{
				BitmapInitNative((FTBitmap*)pabitmap);
			}
		}

		/// <summary>
		/// deprecated <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_New")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BitmapNewNative([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* abitmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTBitmap*, void>)funcTable[81])(abitmap);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[81])((nint)abitmap);
			#endif
		}

		/// <summary>
		/// deprecated <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_New")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BitmapNew([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* abitmap)
		{
			BitmapNewNative(abitmap);
		}

		/// <summary>
		/// deprecated <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_New")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BitmapNew([NativeName(NativeNameType.Param, "abitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap abitmap)
		{
			fixed (FTBitmap* pabitmap = &abitmap)
			{
				BitmapNewNative((FTBitmap*)pabitmap);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError BitmapCopyNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTBitmap*, FTBitmap*, FTError>)funcTable[82])(library, source, target);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, nint, FTError>)funcTable[82])(library, (nint)source, (nint)target);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target)
		{
			FTError ret = BitmapCopyNative(library, source, target);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target)
		{
			fixed (FTBitmap* psource = &source)
			{
				FTError ret = BitmapCopyNative(library, (FTBitmap*)psource, target);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				FTError ret = BitmapCopyNative(library, source, (FTBitmap*)ptarget);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Copy<br/>
		/// <br/>
		/// :<br/>
		/// Copy a bitmap into another one.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// A handle to the source bitmap.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Copy")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapCopy([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					FTError ret = BitmapCopyNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>
		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>
		/// kept unchanged.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// xStrength ::<br/>
		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// yStrength ::<br/>
		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// <br/>
		/// :<br/>
		/// bitmap ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// If you want to embolden the bitmap owned by a <br/>
		/// _GlyphSlotRec, you<br/>
		/// should call <br/>
		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>
		/// Bitmaps in <br/>
		/// _PIXEL_MODE_GRAY2 and <br/>
		/// _PIXEL_MODE_GRAY<br/>
		/// @<br/>
		/// format are<br/>
		/// converted to <br/>
		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError BitmapEmboldenNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTBitmap*, int, int, FTError>)funcTable[83])(library, bitmap, xStrength, yStrength);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, int, int, FTError>)funcTable[83])(library, (nint)bitmap, xStrength, yStrength);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>
		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>
		/// kept unchanged.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// xStrength ::<br/>
		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// yStrength ::<br/>
		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// <br/>
		/// :<br/>
		/// bitmap ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// If you want to embolden the bitmap owned by a <br/>
		/// _GlyphSlotRec, you<br/>
		/// should call <br/>
		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>
		/// Bitmaps in <br/>
		/// _PIXEL_MODE_GRAY2 and <br/>
		/// _PIXEL_MODE_GRAY<br/>
		/// @<br/>
		/// format are<br/>
		/// converted to <br/>
		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapEmbolden([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			FTError ret = BitmapEmboldenNative(library, bitmap, xStrength, yStrength);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Embolden<br/>
		/// <br/>
		/// :<br/>
		/// Embolden a bitmap.  The new bitmap will be about `xStrength` pixels<br/>
		/// wider and `yStrength` pixels higher.  The left and bottom borders are<br/>
		/// kept unchanged.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// xStrength ::<br/>
		/// How strong the glyph is emboldened horizontally.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// yStrength ::<br/>
		/// How strong the glyph is emboldened vertically.  Expressed in 26.6<br/>
		/// pixel format.<br/>
		/// <br/>
		/// :<br/>
		/// bitmap ::<br/>
		/// A handle to the target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// If you want to embolden the bitmap owned by a <br/>
		/// _GlyphSlotRec, you<br/>
		/// should call <br/>
		/// _GlyphSlot_Own_Bitmap on the slot first.<br/>
		/// Bitmaps in <br/>
		/// _PIXEL_MODE_GRAY2 and <br/>
		/// _PIXEL_MODE_GRAY<br/>
		/// @<br/>
		/// format are<br/>
		/// converted to <br/>
		/// _PIXEL_MODE_GRAY format (i.e., 8bpp).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Embolden")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapEmbolden([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap bitmap, [NativeName(NativeNameType.Param, "xStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int xStrength, [NativeName(NativeNameType.Param, "yStrength")] [NativeName(NativeNameType.Type, "FT_Pos")] int yStrength)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				FTError ret = BitmapEmboldenNative(library, (FTBitmap*)pbitmap, xStrength, yStrength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError BitmapConvertNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTBitmap*, FTBitmap*, int, FTError>)funcTable[84])(library, source, target, alignment);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, nint, int, FTError>)funcTable[84])(library, (nint)source, (nint)target, alignment);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			FTError ret = BitmapConvertNative(library, source, target, alignment);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				FTError ret = BitmapConvertNative(library, (FTBitmap*)psource, target, alignment);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				FTError ret = BitmapConvertNative(library, source, (FTBitmap*)ptarget, alignment);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Convert<br/>
		/// <br/>
		/// :<br/>
		/// Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, 8bpp or 32bpp to<br/>
		/// a bitmap object with depth 8bpp, making the number of used bytes per<br/>
		/// line (a.k.a. the 'pitch') a multiple of `alignment`.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap.<br/>
		/// alignment ::<br/>
		/// The pitch of the bitmap is a multiple of this argument.  Common<br/>
		/// values are 1, 2, or 4.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// The target bitmap.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Bitmap_Done to finally remove the bitmap object.<br/>
		/// The `library` argument is taken to have access to FreeType's memory<br/>
		/// handling functions.<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Convert")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapConvert([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "alignment")] [NativeName(NativeNameType.Type, "FT_Int")] int alignment)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					FTError ret = BitmapConvertNative(library, (FTBitmap*)psource, (FTBitmap*)ptarget, alignment);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError BitmapBlendNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTBitmap*, FTVector, FTBitmap*, FTVector*, FTColor, FTError>)funcTable[85])(library, source, sourceOffset, target, atargetOffset, color);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, FTVector, nint, nint, FTColor, FTError>)funcTable[85])(library, (nint)source, sourceOffset, (nint)target, (nint)atargetOffset, color);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			FTError ret = BitmapBlendNative(library, source, sourceOffset, target, atargetOffset, color);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				FTError ret = BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				FTError ret = BitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					FTError ret = BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, atargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTVector* patargetOffset = &atargetOffset)
			{
				FTError ret = BitmapBlendNative(library, source, sourceOffset, target, (FTVector*)patargetOffset, color);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					FTError ret = BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, target, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] FTBitmap* source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* ptarget = &target)
			{
				fixed (FTVector* patargetOffset = &atargetOffset)
				{
					FTError ret = BitmapBlendNative(library, source, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Blend<br/>
		/// <br/>
		/// :<br/>
		/// Blend a bitmap onto another bitmap, using a given color.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// source ::<br/>
		/// The source bitmap, which can have any <br/>
		/// _Pixel_Mode format.<br/>
		/// source_offset ::<br/>
		/// The offset vector to the upper left corner of the source bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// color ::<br/>
		/// The color used to draw `source` onto `target`.<br/>
		/// <br/>
		/// :<br/>
		/// target ::<br/>
		/// A handle to an `FT_Bitmap` object.  It should be either initialized<br/>
		/// as empty with a call to <br/>
		/// _Bitmap_Init, or it should be of type<br/>
		/// <br/>
		/// _PIXEL_MODE_BGRA.<br/>
		/// atarget_offset ::<br/>
		/// The offset vector to the upper left corner of the target bitmap in<br/>
		/// 26.6 pixel format.  It should represent an integer offset; the<br/>
		/// function will set the lowest six bits to zero to enforce that.<br/>
		/// <br/>
		/// <br/>
		/// The bitmap in `target` gets allocated or reallocated as needed; the<br/>
		/// vector `atarget_offset` is updated accordingly.<br/>
		/// In case of allocation or reallocation, the bitmap's pitch is set to<br/>
		/// `4 * width`.  Both `source` and `target` must have the same bitmap<br/>
		/// flow (as indicated by the sign of the `pitch` field).<br/>
		/// `source->buffer` and `target->buffer` must neither be equal nor<br/>
		/// overlap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Blend")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapBlend([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "source")] [NativeName(NativeNameType.Type, "FT_Bitmap const *")] ref FTBitmap source, [NativeName(NativeNameType.Param, "source_offset")] [NativeName(NativeNameType.Type, "FT_Vector const")] FTVector sourceOffset, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap target, [NativeName(NativeNameType.Param, "atarget_offset")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector atargetOffset, [NativeName(NativeNameType.Param, "color")] [NativeName(NativeNameType.Type, "FT_Color")] FTColor color)
		{
			fixed (FTBitmap* psource = &source)
			{
				fixed (FTBitmap* ptarget = &target)
				{
					fixed (FTVector* patargetOffset = &atargetOffset)
					{
						FTError ret = BitmapBlendNative(library, (FTBitmap*)psource, sourceOffset, (FTBitmap*)ptarget, (FTVector*)patargetOffset, color);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_GlyphSlot_Own_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Make sure that a glyph slot owns `slot->bitmap`.<br/>
		/// <br/>
		/// :<br/>
		/// slot ::<br/>
		/// The glyph slot.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Own_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GlyphSlotOwnBitmapNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyphSlot, FTError>)funcTable[86])(slot);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTGlyphSlot, FTError>)funcTable[86])(slot);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_GlyphSlot_Own_Bitmap<br/>
		/// <br/>
		/// :<br/>
		/// Make sure that a glyph slot owns `slot->bitmap`.<br/>
		/// <br/>
		/// :<br/>
		/// slot ::<br/>
		/// The glyph slot.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Own_Bitmap")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphSlotOwnBitmap([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			FTError ret = GlyphSlotOwnBitmapNative(slot);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a bitmap object initialized with <br/>
		/// _Bitmap_Init.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// bitmap ::<br/>
		/// The bitmap object to be freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError BitmapDoneNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* bitmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTBitmap*, FTError>)funcTable[87])(library, bitmap);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, FTError>)funcTable[87])(library, (nint)bitmap);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a bitmap object initialized with <br/>
		/// _Bitmap_Init.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// bitmap ::<br/>
		/// The bitmap object to be freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapDone([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] FTBitmap* bitmap)
		{
			FTError ret = BitmapDoneNative(library, bitmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Bitmap_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a bitmap object initialized with <br/>
		/// _Bitmap_Init.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// A handle to a library object.<br/>
		/// bitmap ::<br/>
		/// The bitmap object to be freed.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Bitmap_Done")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError BitmapDone([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "bitmap")] [NativeName(NativeNameType.Type, "FT_Bitmap *")] ref FTBitmap bitmap)
		{
			fixed (FTBitmap* pbitmap = &bitmap)
			{
				FTError ret = BitmapDoneNative(library, (FTBitmap*)pbitmap);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Return a pointer to a given SFNT table stored within a face.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source.<br/>
		/// tag ::<br/>
		/// The index of the SFNT table.<br/>
		/// <br/>
		/// Use a typecast according to `tag` to access the structure elements.<br/>
		/// <br/>
		/// This function is only useful to access SFNT tables that are loaded by<br/>
		/// the sfnt, truetype, and opentype drivers.  See <br/>
		/// _Sfnt_Tag for a<br/>
		/// list.<br/>
		/// <br/>
		/// Here is an example demonstrating access to the 'vhea' table.<br/>
		/// ```<br/>
		/// TT_VertHeader*  vert_header;<br/>
		/// vert_header =<br/>
		/// (TT_VertHeader*)FT_Get_Sfnt_Table( face, FT_SFNT_VHEA );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* GetSfntTableNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_Sfnt_Tag")] FTSfntTag tag)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, FTSfntTag, void*>)funcTable[88])(face, tag);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<FTFace, FTSfntTag, nint>)funcTable[88])(face, tag);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Return a pointer to a given SFNT table stored within a face.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source.<br/>
		/// tag ::<br/>
		/// The index of the SFNT table.<br/>
		/// <br/>
		/// Use a typecast according to `tag` to access the structure elements.<br/>
		/// <br/>
		/// This function is only useful to access SFNT tables that are loaded by<br/>
		/// the sfnt, truetype, and opentype drivers.  See <br/>
		/// _Sfnt_Tag for a<br/>
		/// list.<br/>
		/// <br/>
		/// Here is an example demonstrating access to the 'vhea' table.<br/>
		/// ```<br/>
		/// TT_VertHeader*  vert_header;<br/>
		/// vert_header =<br/>
		/// (TT_VertHeader*)FT_Get_Sfnt_Table( face, FT_SFNT_VHEA );<br/>
		/// ```<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* GetSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_Sfnt_Tag")] FTSfntTag tag)
		{
			void* ret = GetSfntTableNative(face, tag);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Load any SFNT font table into client memory.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// tag ::<br/>
		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>
		/// access the whole font file.  Otherwise, you can use one of the<br/>
		/// definitions found in the <br/>
		/// _TRUETYPE_TAGS_H file, or forge a new<br/>
		/// one with <br/>
		/// _MAKE_TAG.<br/>
		/// offset ::<br/>
		/// The starting offset in the table (or file if tag~==~0).<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// The target buffer address.  The client must ensure that the memory<br/>
		/// array is big enough to hold the data.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>
		/// Return an error code if it fails.<br/>
		/// Else, if `*length` is~0, exit immediately while returning the<br/>
		/// table's (or file) full size in it.<br/>
		/// Else the number of bytes to read from the table or file, from the<br/>
		/// starting offset.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  length = 0;<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... table does not exist ... }<br/>
		/// buffer = malloc( length );<br/>
		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... could not load table ... }<br/>
		/// ```<br/>
		/// Note that structures like <br/>
		/// _Header or <br/>
		/// _OS2 can't be used with<br/>
		/// this function; they are limited to <br/>
		/// _Get_Sfnt_Table.  Reason is that<br/>
		/// those structures depend on the processor architecture, with varying<br/>
		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError LoadSfntTableNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte *")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, int, byte*, uint*, FTError>)funcTable[89])(face, tag, offset, buffer, length);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, uint, int, nint, nint, FTError>)funcTable[89])(face, tag, offset, (nint)buffer, (nint)length);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Load any SFNT font table into client memory.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// tag ::<br/>
		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>
		/// access the whole font file.  Otherwise, you can use one of the<br/>
		/// definitions found in the <br/>
		/// _TRUETYPE_TAGS_H file, or forge a new<br/>
		/// one with <br/>
		/// _MAKE_TAG.<br/>
		/// offset ::<br/>
		/// The starting offset in the table (or file if tag~==~0).<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// The target buffer address.  The client must ensure that the memory<br/>
		/// array is big enough to hold the data.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>
		/// Return an error code if it fails.<br/>
		/// Else, if `*length` is~0, exit immediately while returning the<br/>
		/// table's (or file) full size in it.<br/>
		/// Else the number of bytes to read from the table or file, from the<br/>
		/// starting offset.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  length = 0;<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... table does not exist ... }<br/>
		/// buffer = malloc( length );<br/>
		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... could not load table ... }<br/>
		/// ```<br/>
		/// Note that structures like <br/>
		/// _Header or <br/>
		/// _OS2 can't be used with<br/>
		/// this function; they are limited to <br/>
		/// _Get_Sfnt_Table.  Reason is that<br/>
		/// those structures depend on the processor architecture, with varying<br/>
		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError LoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte *")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* length)
		{
			FTError ret = LoadSfntTableNative(face, tag, offset, buffer, length);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Load any SFNT font table into client memory.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// tag ::<br/>
		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>
		/// access the whole font file.  Otherwise, you can use one of the<br/>
		/// definitions found in the <br/>
		/// _TRUETYPE_TAGS_H file, or forge a new<br/>
		/// one with <br/>
		/// _MAKE_TAG.<br/>
		/// offset ::<br/>
		/// The starting offset in the table (or file if tag~==~0).<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// The target buffer address.  The client must ensure that the memory<br/>
		/// array is big enough to hold the data.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>
		/// Return an error code if it fails.<br/>
		/// Else, if `*length` is~0, exit immediately while returning the<br/>
		/// table's (or file) full size in it.<br/>
		/// Else the number of bytes to read from the table or file, from the<br/>
		/// starting offset.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  length = 0;<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... table does not exist ... }<br/>
		/// buffer = malloc( length );<br/>
		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... could not load table ... }<br/>
		/// ```<br/>
		/// Note that structures like <br/>
		/// _Header or <br/>
		/// _OS2 can't be used with<br/>
		/// this function; they are limited to <br/>
		/// _Get_Sfnt_Table.  Reason is that<br/>
		/// those structures depend on the processor architecture, with varying<br/>
		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError LoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte *")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				FTError ret = LoadSfntTableNative(face, tag, offset, (byte*)pbuffer, length);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Load any SFNT font table into client memory.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// tag ::<br/>
		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>
		/// access the whole font file.  Otherwise, you can use one of the<br/>
		/// definitions found in the <br/>
		/// _TRUETYPE_TAGS_H file, or forge a new<br/>
		/// one with <br/>
		/// _MAKE_TAG.<br/>
		/// offset ::<br/>
		/// The starting offset in the table (or file if tag~==~0).<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// The target buffer address.  The client must ensure that the memory<br/>
		/// array is big enough to hold the data.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>
		/// Return an error code if it fails.<br/>
		/// Else, if `*length` is~0, exit immediately while returning the<br/>
		/// table's (or file) full size in it.<br/>
		/// Else the number of bytes to read from the table or file, from the<br/>
		/// starting offset.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  length = 0;<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... table does not exist ... }<br/>
		/// buffer = malloc( length );<br/>
		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... could not load table ... }<br/>
		/// ```<br/>
		/// Note that structures like <br/>
		/// _Header or <br/>
		/// _OS2 can't be used with<br/>
		/// this function; they are limited to <br/>
		/// _Get_Sfnt_Table.  Reason is that<br/>
		/// those structures depend on the processor architecture, with varying<br/>
		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError LoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte *")] byte* buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] ref uint length)
		{
			fixed (uint* plength = &length)
			{
				FTError ret = LoadSfntTableNative(face, tag, offset, buffer, (uint*)plength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Load_Sfnt_Table<br/>
		/// <br/>
		/// :<br/>
		/// Load any SFNT font table into client memory.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// tag ::<br/>
		/// The four-byte tag of the table to load.  Use value~0 if you want to<br/>
		/// access the whole font file.  Otherwise, you can use one of the<br/>
		/// definitions found in the <br/>
		/// _TRUETYPE_TAGS_H file, or forge a new<br/>
		/// one with <br/>
		/// _MAKE_TAG.<br/>
		/// offset ::<br/>
		/// The starting offset in the table (or file if tag~==~0).<br/>
		/// <br/>
		/// :<br/>
		/// buffer ::<br/>
		/// The target buffer address.  The client must ensure that the memory<br/>
		/// array is big enough to hold the data.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// If the `length` parameter is `NULL`, try to load the whole table.<br/>
		/// Return an error code if it fails.<br/>
		/// Else, if `*length` is~0, exit immediately while returning the<br/>
		/// table's (or file) full size in it.<br/>
		/// Else the number of bytes to read from the table or file, from the<br/>
		/// starting offset.<br/>
		/// <br/>
		/// <br/>
		/// ```<br/>
		/// FT_ULong  length = 0;<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, NULL, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... table does not exist ... }<br/>
		/// buffer = malloc( length );<br/>
		/// if ( buffer == NULL ) { ... not enough memory ... }<br/>
		/// error = FT_Load_Sfnt_Table( face, tag, 0, buffer, <br/>
		/// &length<br/>
		/// );<br/>
		/// if ( error ) { ... could not load table ... }<br/>
		/// ```<br/>
		/// Note that structures like <br/>
		/// _Header or <br/>
		/// _OS2 can't be used with<br/>
		/// this function; they are limited to <br/>
		/// _Get_Sfnt_Table.  Reason is that<br/>
		/// those structures depend on the processor architecture, with varying<br/>
		/// size (e.g. 32bit vs. 64bit) or order (big endian vs. little endian).<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Load_Sfnt_Table")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError LoadSfntTable([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong")] uint tag, [NativeName(NativeNameType.Param, "offset")] [NativeName(NativeNameType.Type, "FT_Long")] int offset, [NativeName(NativeNameType.Param, "buffer")] [NativeName(NativeNameType.Type, "FT_Byte *")] ref byte buffer, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] ref uint length)
		{
			fixed (byte* pbuffer = &buffer)
			{
				fixed (uint* plength = &length)
				{
					FTError ret = LoadSfntTableNative(face, tag, offset, (byte*)pbuffer, (uint*)plength);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sfnt_Table_Info<br/>
		/// <br/>
		/// :<br/>
		/// Return information on an SFNT table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// table_index ::<br/>
		/// The index of an SFNT table.  The function returns<br/>
		/// FT_Err_Table_Missing for an invalid value.<br/>
		/// <br/>
		/// :<br/>
		/// tag ::<br/>
		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>
		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>
		/// tables in the font.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The length of the SFNT table (or the number of SFNT tables,<br/>
		/// depending on `tag`).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError SfntTableInfoNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* length)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, uint*, uint*, FTError>)funcTable[90])(face, tableIndex, tag, length);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, uint, nint, nint, FTError>)funcTable[90])(face, tableIndex, (nint)tag, (nint)length);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sfnt_Table_Info<br/>
		/// <br/>
		/// :<br/>
		/// Return information on an SFNT table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// table_index ::<br/>
		/// The index of an SFNT table.  The function returns<br/>
		/// FT_Err_Table_Missing for an invalid value.<br/>
		/// <br/>
		/// :<br/>
		/// tag ::<br/>
		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>
		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>
		/// tables in the font.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The length of the SFNT table (or the number of SFNT tables,<br/>
		/// depending on `tag`).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* length)
		{
			FTError ret = SfntTableInfoNative(face, tableIndex, tag, length);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sfnt_Table_Info<br/>
		/// <br/>
		/// :<br/>
		/// Return information on an SFNT table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// table_index ::<br/>
		/// The index of an SFNT table.  The function returns<br/>
		/// FT_Err_Table_Missing for an invalid value.<br/>
		/// <br/>
		/// :<br/>
		/// tag ::<br/>
		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>
		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>
		/// tables in the font.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The length of the SFNT table (or the number of SFNT tables,<br/>
		/// depending on `tag`).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong *")] ref uint tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* length)
		{
			fixed (uint* ptag = &tag)
			{
				FTError ret = SfntTableInfoNative(face, tableIndex, (uint*)ptag, length);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sfnt_Table_Info<br/>
		/// <br/>
		/// :<br/>
		/// Return information on an SFNT table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// table_index ::<br/>
		/// The index of an SFNT table.  The function returns<br/>
		/// FT_Err_Table_Missing for an invalid value.<br/>
		/// <br/>
		/// :<br/>
		/// tag ::<br/>
		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>
		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>
		/// tables in the font.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The length of the SFNT table (or the number of SFNT tables,<br/>
		/// depending on `tag`).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong *")] uint* tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] ref uint length)
		{
			fixed (uint* plength = &length)
			{
				FTError ret = SfntTableInfoNative(face, tableIndex, tag, (uint*)plength);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sfnt_Table_Info<br/>
		/// <br/>
		/// :<br/>
		/// Return information on an SFNT table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// table_index ::<br/>
		/// The index of an SFNT table.  The function returns<br/>
		/// FT_Err_Table_Missing for an invalid value.<br/>
		/// <br/>
		/// :<br/>
		/// tag ::<br/>
		/// The name tag of the SFNT table.  If the value is `NULL`,<br/>
		/// `table_index` is ignored, and `length` returns the number of SFNT<br/>
		/// tables in the font.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The length of the SFNT table (or the number of SFNT tables,<br/>
		/// depending on `tag`).<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sfnt_Table_Info")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError SfntTableInfo([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "table_index")] [NativeName(NativeNameType.Type, "FT_UInt")] uint tableIndex, [NativeName(NativeNameType.Param, "tag")] [NativeName(NativeNameType.Type, "FT_ULong *")] ref uint tag, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_ULong *")] ref uint length)
		{
			fixed (uint* ptag = &tag)
			{
				fixed (uint* plength = &length)
				{
					FTError ret = SfntTableInfoNative(face, tableIndex, (uint*)ptag, (uint*)plength);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_CMap_Language_ID<br/>
		/// <br/>
		/// :<br/>
		/// Return cmap language ID as specified in the OpenType standard.<br/>
		/// Definitions of language ID values are in file <br/>
		/// _TRUETYPE_IDS_H.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// The target charmap.<br/>
		/// <br/>
		/// For a format~14 cmap (to access Unicode IVS), the return value is<br/>
		/// 0xFFFFFFFF.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_CMap_Language_ID")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCMapLanguageIDNative([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTCharMap, uint>)funcTable[91])(charmap);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<FTCharMap, uint>)funcTable[91])(charmap);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_CMap_Language_ID<br/>
		/// <br/>
		/// :<br/>
		/// Return cmap language ID as specified in the OpenType standard.<br/>
		/// Definitions of language ID values are in file <br/>
		/// _TRUETYPE_IDS_H.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// The target charmap.<br/>
		/// <br/>
		/// For a format~14 cmap (to access Unicode IVS), the return value is<br/>
		/// 0xFFFFFFFF.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_CMap_Language_ID")]
		[return: NativeName(NativeNameType.Type, "FT_ULong")]
		public static uint GetCMapLanguageID([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			uint ret = GetCMapLanguageIDNative(charmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_CMap_Format<br/>
		/// <br/>
		/// :<br/>
		/// Return the format of an SFNT 'cmap' table.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// The target charmap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_CMap_Format")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetCMapFormatNative([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTCharMap, int>)funcTable[92])(charmap);
			#else
			return (int)((delegate* unmanaged[Cdecl]<FTCharMap, int>)funcTable[92])(charmap);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_CMap_Format<br/>
		/// <br/>
		/// :<br/>
		/// Return the format of an SFNT 'cmap' table.<br/>
		/// <br/>
		/// :<br/>
		/// charmap ::<br/>
		/// The target charmap.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_CMap_Format")]
		[return: NativeName(NativeNameType.Type, "FT_Long")]
		public static int GetCMapFormat([NativeName(NativeNameType.Param, "charmap")] [NativeName(NativeNameType.Type, "FT_CharMap")] FTCharMap charmap)
		{
			int ret = GetCMapFormatNative(charmap);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name_Count<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the number of name strings in the SFNT 'name' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name_Count")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSfntNameCountNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint>)funcTable[93])(face);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<FTFace, uint>)funcTable[93])(face);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name_Count<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the number of name strings in the SFNT 'name' table.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name_Count")]
		[return: NativeName(NativeNameType.Type, "FT_UInt")]
		public static uint GetSfntNameCount([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face)
		{
			uint ret = GetSfntNameCountNative(face);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a string of the SFNT 'name' table for a given index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// idx ::<br/>
		/// The index of the 'name' string.<br/>
		/// <br/>
		/// :<br/>
		/// aname ::<br/>
		/// The indexed <br/>
		/// _SfntName structure.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Get_Sfnt_Name_Count to get the total number of available<br/>
		/// 'name' table entries, then do a loop until you get the right platform,<br/>
		/// encoding, and name ID.<br/>
		/// 'name' table format~1 entries can use language tags also, see<br/>
		/// <br/>
		/// _Get_Sfnt_LangTag.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GetSfntNameNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName *")] FTSfntName* aname)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, FTSfntName*, FTError>)funcTable[94])(face, idx, aname);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, uint, nint, FTError>)funcTable[94])(face, idx, (nint)aname);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a string of the SFNT 'name' table for a given index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// idx ::<br/>
		/// The index of the 'name' string.<br/>
		/// <br/>
		/// :<br/>
		/// aname ::<br/>
		/// The indexed <br/>
		/// _SfntName structure.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Get_Sfnt_Name_Count to get the total number of available<br/>
		/// 'name' table entries, then do a loop until you get the right platform,<br/>
		/// encoding, and name ID.<br/>
		/// 'name' table format~1 entries can use language tags also, see<br/>
		/// <br/>
		/// _Get_Sfnt_LangTag.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSfntName([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName *")] FTSfntName* aname)
		{
			FTError ret = GetSfntNameNative(face, idx, aname);
			return ret;
		}
	}
}
