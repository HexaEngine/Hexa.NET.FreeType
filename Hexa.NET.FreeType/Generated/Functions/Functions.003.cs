// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	public unsafe partial class FreeType
	{

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_Name<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve a string of the SFNT 'name' table for a given index.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// idx ::<br/>
		/// The index of the 'name' string.<br/>
		/// <br/>
		/// :<br/>
		/// aname ::<br/>
		/// The indexed <br/>
		/// _SfntName structure.<br/>
		/// <br/>
		/// <br/>
		/// Use <br/>
		/// _Get_Sfnt_Name_Count to get the total number of available<br/>
		/// 'name' table entries, then do a loop until you get the right platform,<br/>
		/// encoding, and name ID.<br/>
		/// 'name' table format~1 entries can use language tags also, see<br/>
		/// <br/>
		/// _Get_Sfnt_LangTag.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_Name")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSfntName([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "idx")] [NativeName(NativeNameType.Type, "FT_UInt")] uint idx, [NativeName(NativeNameType.Param, "aname")] [NativeName(NativeNameType.Type, "FT_SfntName *")] ref FTSfntName aname)
		{
			fixed (FTSfntName* paname = &aname)
			{
				FTError ret = GetSfntNameNative(face, idx, (FTSfntName*)paname);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_LangTag<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the language tag associated with a language ID of an SFNT<br/>
		/// 'name' table entry.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// langID ::<br/>
		/// The language ID, as returned by <br/>
		/// _Get_Sfnt_Name.  This is always a<br/>
		/// value larger than 0x8000.<br/>
		/// <br/>
		/// :<br/>
		/// alangTag ::<br/>
		/// The language tag associated with the 'name' table entry's language<br/>
		/// ID.<br/>
		/// <br/>
		/// <br/>
		/// Only 'name' table format~1 supports language tags.  For format~0<br/>
		/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>
		/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>
		/// returned.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GetSfntLangTagNative([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag *")] FTSfntLangTag* alangTag)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTFace, uint, FTSfntLangTag*, FTError>)funcTable[95])(face, langID, alangTag);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTFace, uint, nint, FTError>)funcTable[95])(face, langID, (nint)alangTag);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_LangTag<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the language tag associated with a language ID of an SFNT<br/>
		/// 'name' table entry.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// langID ::<br/>
		/// The language ID, as returned by <br/>
		/// _Get_Sfnt_Name.  This is always a<br/>
		/// value larger than 0x8000.<br/>
		/// <br/>
		/// :<br/>
		/// alangTag ::<br/>
		/// The language tag associated with the 'name' table entry's language<br/>
		/// ID.<br/>
		/// <br/>
		/// <br/>
		/// Only 'name' table format~1 supports language tags.  For format~0<br/>
		/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>
		/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>
		/// returned.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSfntLangTag([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag *")] FTSfntLangTag* alangTag)
		{
			FTError ret = GetSfntLangTagNative(face, langID, alangTag);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Get_Sfnt_LangTag<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the language tag associated with a language ID of an SFNT<br/>
		/// 'name' table entry.<br/>
		/// <br/>
		/// :<br/>
		/// face ::<br/>
		/// A handle to the source face.<br/>
		/// langID ::<br/>
		/// The language ID, as returned by <br/>
		/// _Get_Sfnt_Name.  This is always a<br/>
		/// value larger than 0x8000.<br/>
		/// <br/>
		/// :<br/>
		/// alangTag ::<br/>
		/// The language tag associated with the 'name' table entry's language<br/>
		/// ID.<br/>
		/// <br/>
		/// <br/>
		/// Only 'name' table format~1 supports language tags.  For format~0<br/>
		/// tables, this function always returns FT_Err_Invalid_Table.  For<br/>
		/// invalid format~1 language ID values, FT_Err_Invalid_Argument is<br/>
		/// returned.<br/>
		/// This function always returns an error if the config macro<br/>
		/// `TT_CONFIG_OPTION_SFNT_NAMES` is not defined in `ftoption.h`.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Get_Sfnt_LangTag")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GetSfntLangTag([NativeName(NativeNameType.Param, "face")] [NativeName(NativeNameType.Type, "FT_Face")] FTFace face, [NativeName(NativeNameType.Param, "langID")] [NativeName(NativeNameType.Type, "FT_UInt")] uint langID, [NativeName(NativeNameType.Param, "alangTag")] [NativeName(NativeNameType.Type, "FT_SfntLangTag *")] ref FTSfntLangTag alangTag)
		{
			fixed (FTSfntLangTag* palangTag = &alangTag)
			{
				FTError ret = GetSfntLangTagNative(face, langID, (FTSfntLangTag*)palangTag);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_BBox<br/>
		/// <br/>
		/// :<br/>
		/// Compute the exact bounding box of an outline.  This is slower than<br/>
		/// computing the control box.  However, it uses an advanced algorithm<br/>
		/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>
		/// the outline Bezier arcs are traversed to extract their extrema.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// abbox ::<br/>
		/// The outline's exact bounding box.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError OutlineGetBBoxNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* abbox)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTBBox*, FTError>)funcTable[96])(outline, abbox);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, nint, FTError>)funcTable[96])((nint)outline, (nint)abbox);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_BBox<br/>
		/// <br/>
		/// :<br/>
		/// Compute the exact bounding box of an outline.  This is slower than<br/>
		/// computing the control box.  However, it uses an advanced algorithm<br/>
		/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>
		/// the outline Bezier arcs are traversed to extract their extrema.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// abbox ::<br/>
		/// The outline's exact bounding box.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* abbox)
		{
			FTError ret = OutlineGetBBoxNative(outline, abbox);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_BBox<br/>
		/// <br/>
		/// :<br/>
		/// Compute the exact bounding box of an outline.  This is slower than<br/>
		/// computing the control box.  However, it uses an advanced algorithm<br/>
		/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>
		/// the outline Bezier arcs are traversed to extract their extrema.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// abbox ::<br/>
		/// The outline's exact bounding box.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] FTBBox* abbox)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = OutlineGetBBoxNative((FTOutline*)poutline, abbox);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_BBox<br/>
		/// <br/>
		/// :<br/>
		/// Compute the exact bounding box of an outline.  This is slower than<br/>
		/// computing the control box.  However, it uses an advanced algorithm<br/>
		/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>
		/// the outline Bezier arcs are traversed to extract their extrema.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// abbox ::<br/>
		/// The outline's exact bounding box.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] ref FTBBox abbox)
		{
			fixed (FTBBox* pabbox = &abbox)
			{
				FTError ret = OutlineGetBBoxNative(outline, (FTBBox*)pabbox);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_Get_BBox<br/>
		/// <br/>
		/// :<br/>
		/// Compute the exact bounding box of an outline.  This is slower than<br/>
		/// computing the control box.  However, it uses an advanced algorithm<br/>
		/// that returns _very_ quickly when the two boxes coincide.  Otherwise,<br/>
		/// the outline Bezier arcs are traversed to extract their extrema.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// A pointer to the source outline.<br/>
		/// <br/>
		/// :<br/>
		/// abbox ::<br/>
		/// The outline's exact bounding box.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_Get_BBox")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError OutlineGetBBox([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "abbox")] [NativeName(NativeNameType.Type, "FT_BBox *")] ref FTBBox abbox)
		{
			fixed (FTOutline* poutline = &outline)
			{
				fixed (FTBBox* pabbox = &abbox)
				{
					FTError ret = OutlineGetBBoxNative((FTOutline*)poutline, (FTBBox*)pabbox);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetInsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'inside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetInsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTStrokerBorder OutlineGetInsideBorderNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTStrokerBorder>)funcTable[97])(outline);
			#else
			return (FTStrokerBorder)((delegate* unmanaged[Cdecl]<nint, FTStrokerBorder>)funcTable[97])((nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetInsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'inside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetInsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		public static FTStrokerBorder OutlineGetInsideBorder([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FTStrokerBorder ret = OutlineGetInsideBorderNative(outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetInsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'inside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetInsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		public static FTStrokerBorder OutlineGetInsideBorder([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTStrokerBorder ret = OutlineGetInsideBorderNative((FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetOutsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'outside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetOutsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTStrokerBorder OutlineGetOutsideBorderNative([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTOutline*, FTStrokerBorder>)funcTable[98])(outline);
			#else
			return (FTStrokerBorder)((delegate* unmanaged[Cdecl]<nint, FTStrokerBorder>)funcTable[98])((nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetOutsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'outside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetOutsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		public static FTStrokerBorder OutlineGetOutsideBorder([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			FTStrokerBorder ret = OutlineGetOutsideBorderNative(outline);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Outline_GetOutsideBorder<br/>
		/// <br/>
		/// :<br/>
		/// Retrieve the <br/>
		/// _StrokerBorder value corresponding to the 'outside'<br/>
		/// borders of a given outline.<br/>
		/// <br/>
		/// :<br/>
		/// outline ::<br/>
		/// The source outline handle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Outline_GetOutsideBorder")]
		[return: NativeName(NativeNameType.Type, "FT_StrokerBorder")]
		public static FTStrokerBorder OutlineGetOutsideBorder([NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTStrokerBorder ret = OutlineGetOutsideBorderNative((FTOutline*)poutline);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// FreeType library handle.<br/>
		/// <br/>
		/// :<br/>
		/// astroker ::<br/>
		/// A new stroker object handle.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerNewNative([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker *")] FTStroker* astroker)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTLibrary, FTStroker*, FTError>)funcTable[99])(library, astroker);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTLibrary, nint, FTError>)funcTable[99])(library, (nint)astroker);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// FreeType library handle.<br/>
		/// <br/>
		/// :<br/>
		/// astroker ::<br/>
		/// A new stroker object handle.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerNew([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker *")] FTStroker* astroker)
		{
			FTError ret = StrokerNewNative(library, astroker);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_New<br/>
		/// <br/>
		/// :<br/>
		/// Create a new stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// library ::<br/>
		/// FreeType library handle.<br/>
		/// <br/>
		/// :<br/>
		/// astroker ::<br/>
		/// A new stroker object handle.  `NULL` in case of error.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_New")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerNew([NativeName(NativeNameType.Param, "library")] [NativeName(NativeNameType.Type, "FT_Library")] FTLibrary library, [NativeName(NativeNameType.Param, "astroker")] [NativeName(NativeNameType.Type, "FT_Stroker *")] ref FTStroker astroker)
		{
			fixed (FTStroker* pastroker = &astroker)
			{
				FTError ret = StrokerNewNative(library, (FTStroker*)pastroker);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Set<br/>
		/// <br/>
		/// :<br/>
		/// Reset a stroker object's attributes.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// radius ::<br/>
		/// The border radius.<br/>
		/// line_cap ::<br/>
		/// The line cap style.<br/>
		/// line_join ::<br/>
		/// The line join style.<br/>
		/// miter_limit ::<br/>
		/// The maximum reciprocal sine of half-angle at the miter join,<br/>
		/// expressed as 16.16 fixed-point value.<br/>
		/// <br/>
		/// The `miter_limit` multiplied by the `radius` gives the maximum size<br/>
		/// of a miter spike, at which it is clipped for<br/>
		/// <br/>
		/// _STROKER_LINEJOIN_MITER_VARIABLE or replaced with a bevel join for<br/>
		/// <br/>
		/// _STROKER_LINEJOIN_MITER_FIXED.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Set")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StrokerSetNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "FT_Fixed")] int radius, [NativeName(NativeNameType.Param, "line_cap")] [NativeName(NativeNameType.Type, "FT_Stroker_LineCap")] FTStrokerLineCap lineCap, [NativeName(NativeNameType.Param, "line_join")] [NativeName(NativeNameType.Type, "FT_Stroker_LineJoin")] FTStrokerLineJoin lineJoin, [NativeName(NativeNameType.Param, "miter_limit")] [NativeName(NativeNameType.Type, "FT_Fixed")] int miterLimit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTStroker, int, FTStrokerLineCap, FTStrokerLineJoin, int, void>)funcTable[100])(stroker, radius, lineCap, lineJoin, miterLimit);
			#else
			((delegate* unmanaged[Cdecl]<FTStroker, int, FTStrokerLineCap, FTStrokerLineJoin, int, void>)funcTable[100])(stroker, radius, lineCap, lineJoin, miterLimit);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Set<br/>
		/// <br/>
		/// :<br/>
		/// Reset a stroker object's attributes.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// radius ::<br/>
		/// The border radius.<br/>
		/// line_cap ::<br/>
		/// The line cap style.<br/>
		/// line_join ::<br/>
		/// The line join style.<br/>
		/// miter_limit ::<br/>
		/// The maximum reciprocal sine of half-angle at the miter join,<br/>
		/// expressed as 16.16 fixed-point value.<br/>
		/// <br/>
		/// The `miter_limit` multiplied by the `radius` gives the maximum size<br/>
		/// of a miter spike, at which it is clipped for<br/>
		/// <br/>
		/// _STROKER_LINEJOIN_MITER_VARIABLE or replaced with a bevel join for<br/>
		/// <br/>
		/// _STROKER_LINEJOIN_MITER_FIXED.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Set")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerSet([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "FT_Fixed")] int radius, [NativeName(NativeNameType.Param, "line_cap")] [NativeName(NativeNameType.Type, "FT_Stroker_LineCap")] FTStrokerLineCap lineCap, [NativeName(NativeNameType.Param, "line_join")] [NativeName(NativeNameType.Type, "FT_Stroker_LineJoin")] FTStrokerLineJoin lineJoin, [NativeName(NativeNameType.Param, "miter_limit")] [NativeName(NativeNameType.Type, "FT_Fixed")] int miterLimit)
		{
			StrokerSetNative(stroker, radius, lineCap, lineJoin, miterLimit);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Rewind<br/>
		/// <br/>
		/// :<br/>
		/// Reset a stroker object without changing its attributes.  You should<br/>
		/// call this function before beginning a new series of calls to<br/>
		/// <br/>
		/// _Stroker_BeginSubPath or <br/>
		/// _Stroker_EndSubPath.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Rewind")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StrokerRewindNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTStroker, void>)funcTable[101])(stroker);
			#else
			((delegate* unmanaged[Cdecl]<FTStroker, void>)funcTable[101])(stroker);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Rewind<br/>
		/// <br/>
		/// :<br/>
		/// Reset a stroker object without changing its attributes.  You should<br/>
		/// call this function before beginning a new series of calls to<br/>
		/// <br/>
		/// _Stroker_BeginSubPath or <br/>
		/// _Stroker_EndSubPath.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Rewind")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerRewind([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			StrokerRewindNative(stroker);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ParseOutline<br/>
		/// <br/>
		/// :<br/>
		/// A convenience function used to parse a whole outline with the stroker.<br/>
		/// The resulting outline(s) can be retrieved later by functions like<br/>
		/// <br/>
		/// _Stroker_GetCounts and <br/>
		/// _Stroker_Export.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The source outline.<br/>
		/// opened ::<br/>
		/// A boolean.  If~1, the outline is treated as an open path instead of<br/>
		/// a closed one.<br/>
		/// <br/>
		/// <br/>
		/// If `opened` is~1, the outline is processed as an open path, and the<br/>
		/// stroker generates a single 'stroke' outline.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerParseOutlineNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTOutline*, byte, FTError>)funcTable[102])(stroker, outline, opened);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, nint, byte, FTError>)funcTable[102])(stroker, (nint)outline, opened);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ParseOutline<br/>
		/// <br/>
		/// :<br/>
		/// A convenience function used to parse a whole outline with the stroker.<br/>
		/// The resulting outline(s) can be retrieved later by functions like<br/>
		/// <br/>
		/// _Stroker_GetCounts and <br/>
		/// _Stroker_Export.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The source outline.<br/>
		/// opened ::<br/>
		/// A boolean.  If~1, the outline is treated as an open path instead of<br/>
		/// a closed one.<br/>
		/// <br/>
		/// <br/>
		/// If `opened` is~1, the outline is processed as an open path, and the<br/>
		/// stroker generates a single 'stroke' outline.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerParseOutline([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			FTError ret = StrokerParseOutlineNative(stroker, outline, opened);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ParseOutline<br/>
		/// <br/>
		/// :<br/>
		/// A convenience function used to parse a whole outline with the stroker.<br/>
		/// The resulting outline(s) can be retrieved later by functions like<br/>
		/// <br/>
		/// _Stroker_GetCounts and <br/>
		/// _Stroker_Export.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The source outline.<br/>
		/// opened ::<br/>
		/// A boolean.  If~1, the outline is treated as an open path instead of<br/>
		/// a closed one.<br/>
		/// <br/>
		/// <br/>
		/// If `opened` is~1, the outline is processed as an open path, and the<br/>
		/// stroker generates a single 'stroke' outline.<br/>
		/// This function calls <br/>
		/// _Stroker_Rewind automatically.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ParseOutline")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerParseOutline([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline, [NativeName(NativeNameType.Param, "opened")] [NativeName(NativeNameType.Type, "FT_Bool")] byte opened)
		{
			fixed (FTOutline* poutline = &outline)
			{
				FTError ret = StrokerParseOutlineNative(stroker, (FTOutline*)poutline, opened);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_BeginSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Start a new sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the start vector.<br/>
		/// open ::<br/>
		/// A boolean.  If~1, the sub-path is treated as an open one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerBeginSubPathNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTVector*, byte, FTError>)funcTable[103])(stroker, to, open);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, nint, byte, FTError>)funcTable[103])(stroker, (nint)to, open);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_BeginSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Start a new sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the start vector.<br/>
		/// open ::<br/>
		/// A boolean.  If~1, the sub-path is treated as an open one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerBeginSubPath([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			FTError ret = StrokerBeginSubPathNative(stroker, to, open);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_BeginSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Start a new sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the start vector.<br/>
		/// open ::<br/>
		/// A boolean.  If~1, the sub-path is treated as an open one.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_BeginSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerBeginSubPath([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to, [NativeName(NativeNameType.Param, "open")] [NativeName(NativeNameType.Type, "FT_Bool")] byte open)
		{
			fixed (FTVector* pto = &to)
			{
				FTError ret = StrokerBeginSubPathNative(stroker, (FTVector*)pto, open);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_EndSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Close the current sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_EndSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerEndSubPathNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTError>)funcTable[104])(stroker);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, FTError>)funcTable[104])(stroker);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_EndSubPath<br/>
		/// <br/>
		/// :<br/>
		/// Close the current sub-path in the stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_EndSubPath")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerEndSubPath([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			FTError ret = StrokerEndSubPathNative(stroker);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_LineTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerLineToNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTVector*, FTError>)funcTable[105])(stroker, to);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, nint, FTError>)funcTable[105])(stroker, (nint)to);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_LineTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerLineTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			FTError ret = StrokerLineToNative(stroker, to);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_LineTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single line segment in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_LineTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerLineTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				FTError ret = StrokerLineToNative(stroker, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ConicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>
		/// from the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control ::<br/>
		/// A pointer to a Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerConicToNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTVector*, FTVector*, FTError>)funcTable[106])(stroker, control, to);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, nint, nint, FTError>)funcTable[106])(stroker, (nint)control, (nint)to);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ConicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>
		/// from the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control ::<br/>
		/// A pointer to a Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			FTError ret = StrokerConicToNative(stroker, control, to);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ConicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>
		/// from the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control ::<br/>
		/// A pointer to a Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			fixed (FTVector* pcontrol = &control)
			{
				FTError ret = StrokerConicToNative(stroker, (FTVector*)pcontrol, to);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ConicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>
		/// from the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control ::<br/>
		/// A pointer to a Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				FTError ret = StrokerConicToNative(stroker, control, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ConicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single quadratic Bezier in the stroker's current sub-path,<br/>
		/// from the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control ::<br/>
		/// A pointer to a Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ConicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerConicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol = &control)
			{
				fixed (FTVector* pto = &to)
				{
					FTError ret = StrokerConicToNative(stroker, (FTVector*)pcontrol, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerCubicToNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTVector*, FTVector*, FTVector*, FTError>)funcTable[107])(stroker, control1, control2, to);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, nint, nint, nint, FTError>)funcTable[107])(stroker, (nint)control1, (nint)control2, (nint)to);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			FTError ret = StrokerCubicToNative(stroker, control1, control2, to);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				FTError ret = StrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, to);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				FTError ret = StrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, to);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					FTError ret = StrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, to);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pto = &to)
			{
				FTError ret = StrokerCubicToNative(stroker, control1, control2, (FTVector*)pto);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pto = &to)
				{
					FTError ret = StrokerCubicToNative(stroker, (FTVector*)pcontrol1, control2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol2 = &control2)
			{
				fixed (FTVector* pto = &to)
				{
					FTError ret = StrokerCubicToNative(stroker, control1, (FTVector*)pcontrol2, (FTVector*)pto);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_CubicTo<br/>
		/// <br/>
		/// :<br/>
		/// 'Draw' a single cubic Bezier in the stroker's current sub-path, from<br/>
		/// the last position.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// control1 ::<br/>
		/// A pointer to the first Bezier control point.<br/>
		/// control2 ::<br/>
		/// A pointer to second Bezier control point.<br/>
		/// to ::<br/>
		/// A pointer to the destination point.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_CubicTo")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerCubicTo([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "control1")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control1, [NativeName(NativeNameType.Param, "control2")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector control2, [NativeName(NativeNameType.Param, "to")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector to)
		{
			fixed (FTVector* pcontrol1 = &control1)
			{
				fixed (FTVector* pcontrol2 = &control2)
				{
					fixed (FTVector* pto = &to)
					{
						FTError ret = StrokerCubicToNative(stroker, (FTVector*)pcontrol1, (FTVector*)pcontrol2, (FTVector*)pto);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerGetBorderCountsNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, FTStrokerBorder, uint*, uint*, FTError>)funcTable[108])(stroker, border, anumPoints, anumContours);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, FTStrokerBorder, nint, nint, FTError>)funcTable[108])(stroker, border, (nint)anumPoints, (nint)anumContours);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			FTError ret = StrokerGetBorderCountsNative(stroker, border, anumPoints, anumContours);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				FTError ret = StrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				FTError ret = StrokerGetBorderCountsNative(stroker, border, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetBorderCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export one of the 'border' or 'stroke' outlines generated by the<br/>
		/// stroker.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// <br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_GetCounts instead if you want to retrieve<br/>
		/// the counts associated to both borders.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetBorderCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetBorderCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					FTError ret = StrokerGetBorderCountsNative(stroker, border, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ExportBorder<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export the<br/>
		/// corresponding border to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// <br/>
		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>
		/// independent 'border' outlines, named 'left' and 'right'.<br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_Export instead if you want to retrieve<br/>
		/// all borders at once.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StrokerExportBorderNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTStroker, FTStrokerBorder, FTOutline*, void>)funcTable[109])(stroker, border, outline);
			#else
			((delegate* unmanaged[Cdecl]<FTStroker, FTStrokerBorder, nint, void>)funcTable[109])(stroker, border, (nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ExportBorder<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export the<br/>
		/// corresponding border to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// <br/>
		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>
		/// independent 'border' outlines, named 'left' and 'right'.<br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_Export instead if you want to retrieve<br/>
		/// all borders at once.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerExportBorder([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			StrokerExportBorderNative(stroker, border, outline);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_ExportBorder<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export the<br/>
		/// corresponding border to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// border ::<br/>
		/// The border index.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// <br/>
		/// When an outline, or a sub-path, is 'closed', the stroker generates two<br/>
		/// independent 'border' outlines, named 'left' and 'right'.<br/>
		/// When the outline, or a sub-path, is 'opened', the stroker merges the<br/>
		/// 'border' outlines with caps.  The 'left' border receives all points,<br/>
		/// while the 'right' border becomes empty.<br/>
		/// Use the function <br/>
		/// _Stroker_Export instead if you want to retrieve<br/>
		/// all borders at once.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_ExportBorder")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerExportBorder([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "border")] [NativeName(NativeNameType.Type, "FT_StrokerBorder")] FTStrokerBorder border, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				StrokerExportBorderNative(stroker, border, (FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError StrokerGetCountsNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTStroker, uint*, uint*, FTError>)funcTable[110])(stroker, anumPoints, anumContours);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<FTStroker, nint, nint, FTError>)funcTable[110])(stroker, (nint)anumPoints, (nint)anumContours);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			FTError ret = StrokerGetCountsNative(stroker, anumPoints, anumContours);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				FTError ret = StrokerGetCountsNative(stroker, (uint*)panumPoints, anumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] uint* anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumContours = &anumContours)
			{
				FTError ret = StrokerGetCountsNative(stroker, anumPoints, (uint*)panumContours);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_GetCounts<br/>
		/// <br/>
		/// :<br/>
		/// Call this function once you have finished parsing your paths with the<br/>
		/// stroker.  It returns the number of points and contours necessary to<br/>
		/// export all points/borders from the stroked outline/path.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// <br/>
		/// :<br/>
		/// anum_points ::<br/>
		/// The number of points.<br/>
		/// anum_contours ::<br/>
		/// The number of contours.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_GetCounts")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError StrokerGetCounts([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "anum_points")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumPoints, [NativeName(NativeNameType.Param, "anum_contours")] [NativeName(NativeNameType.Type, "FT_UInt *")] ref uint anumContours)
		{
			fixed (uint* panumPoints = &anumPoints)
			{
				fixed (uint* panumContours = &anumContours)
				{
					FTError ret = StrokerGetCountsNative(stroker, (uint*)panumPoints, (uint*)panumContours);
					return ret;
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Export<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export all<br/>
		/// borders to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StrokerExportNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTStroker, FTOutline*, void>)funcTable[111])(stroker, outline);
			#else
			((delegate* unmanaged[Cdecl]<FTStroker, nint, void>)funcTable[111])(stroker, (nint)outline);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Export<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export all<br/>
		/// borders to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerExport([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] FTOutline* outline)
		{
			StrokerExportNative(stroker, outline);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Export<br/>
		/// <br/>
		/// :<br/>
		/// Call this function after <br/>
		/// _Stroker_GetBorderCounts to export all<br/>
		/// borders to your own <br/>
		/// _Outline structure.<br/>
		/// Note that this function appends the border points and contours to your<br/>
		/// outline, but does not try to resize its arrays.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// The target stroker handle.<br/>
		/// outline ::<br/>
		/// The target outline handle.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Export")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerExport([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "outline")] [NativeName(NativeNameType.Type, "FT_Outline *")] ref FTOutline outline)
		{
			fixed (FTOutline* poutline = &outline)
			{
				StrokerExportNative(stroker, (FTOutline*)poutline);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.  Can be `NULL`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Done")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StrokerDoneNative([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTStroker, void>)funcTable[112])(stroker);
			#else
			((delegate* unmanaged[Cdecl]<FTStroker, void>)funcTable[112])(stroker);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Stroker_Done<br/>
		/// <br/>
		/// :<br/>
		/// Destroy a stroker object.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.  Can be `NULL`.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Stroker_Done")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void StrokerDone([NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker)
		{
			StrokerDoneNative(stroker);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Stroke<br/>
		/// <br/>
		/// :<br/>
		/// Stroke a given outline glyph object with a given stroker.<br/>
		/// <br/>
		/// :<br/>
		/// pglyph ::<br/>
		/// Source glyph handle on input, new glyph handle on output.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.<br/>
		/// destroy ::<br/>
		/// A Boolean.  If~1, the source glyph object is destroyed on success.<br/>
		/// <br/>
		/// <br/>
		/// Adding stroke may yield a significantly wider and taller glyph<br/>
		/// depending on how large of a radius was used to stroke the glyph.  You<br/>
		/// may need to manually adjust horizontal and vertical advance amounts to<br/>
		/// account for this added size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Stroke")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GlyphStrokeNative([NativeName(NativeNameType.Param, "pglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* pglyph, [NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyph*, FTStroker, byte, FTError>)funcTable[113])(pglyph, stroker, destroy);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, FTStroker, byte, FTError>)funcTable[113])((nint)pglyph, stroker, destroy);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Stroke<br/>
		/// <br/>
		/// :<br/>
		/// Stroke a given outline glyph object with a given stroker.<br/>
		/// <br/>
		/// :<br/>
		/// pglyph ::<br/>
		/// Source glyph handle on input, new glyph handle on output.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.<br/>
		/// destroy ::<br/>
		/// A Boolean.  If~1, the source glyph object is destroyed on success.<br/>
		/// <br/>
		/// <br/>
		/// Adding stroke may yield a significantly wider and taller glyph<br/>
		/// depending on how large of a radius was used to stroke the glyph.  You<br/>
		/// may need to manually adjust horizontal and vertical advance amounts to<br/>
		/// account for this added size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Stroke")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphStroke([NativeName(NativeNameType.Param, "pglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* pglyph, [NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			FTError ret = GlyphStrokeNative(pglyph, stroker, destroy);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_Stroke<br/>
		/// <br/>
		/// :<br/>
		/// Stroke a given outline glyph object with a given stroker.<br/>
		/// <br/>
		/// :<br/>
		/// pglyph ::<br/>
		/// Source glyph handle on input, new glyph handle on output.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.<br/>
		/// destroy ::<br/>
		/// A Boolean.  If~1, the source glyph object is destroyed on success.<br/>
		/// <br/>
		/// <br/>
		/// Adding stroke may yield a significantly wider and taller glyph<br/>
		/// depending on how large of a radius was used to stroke the glyph.  You<br/>
		/// may need to manually adjust horizontal and vertical advance amounts to<br/>
		/// account for this added size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_Stroke")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphStroke([NativeName(NativeNameType.Param, "pglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph pglyph, [NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			fixed (FTGlyph* ppglyph = &pglyph)
			{
				FTError ret = GlyphStrokeNative((FTGlyph*)ppglyph, stroker, destroy);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_StrokeBorder<br/>
		/// <br/>
		/// :<br/>
		/// Stroke a given outline glyph object with a given stroker, but only<br/>
		/// return either its inside or outside border.<br/>
		/// <br/>
		/// :<br/>
		/// pglyph ::<br/>
		/// Source glyph handle on input, new glyph handle on output.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.<br/>
		/// inside ::<br/>
		/// A Boolean.  If~1, return the inside border, otherwise the outside<br/>
		/// border.<br/>
		/// destroy ::<br/>
		/// A Boolean.  If~1, the source glyph object is destroyed on success.<br/>
		/// <br/>
		/// <br/>
		/// Adding stroke may yield a significantly wider and taller glyph<br/>
		/// depending on how large of a radius was used to stroke the glyph.  You<br/>
		/// may need to manually adjust horizontal and vertical advance amounts to<br/>
		/// account for this added size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_StrokeBorder")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static FTError GlyphStrokeBorderNative([NativeName(NativeNameType.Param, "pglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* pglyph, [NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "inside")] [NativeName(NativeNameType.Type, "FT_Bool")] byte inside, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTGlyph*, FTStroker, byte, byte, FTError>)funcTable[114])(pglyph, stroker, inside, destroy);
			#else
			return (FTError)((delegate* unmanaged[Cdecl]<nint, FTStroker, byte, byte, FTError>)funcTable[114])((nint)pglyph, stroker, inside, destroy);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_StrokeBorder<br/>
		/// <br/>
		/// :<br/>
		/// Stroke a given outline glyph object with a given stroker, but only<br/>
		/// return either its inside or outside border.<br/>
		/// <br/>
		/// :<br/>
		/// pglyph ::<br/>
		/// Source glyph handle on input, new glyph handle on output.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.<br/>
		/// inside ::<br/>
		/// A Boolean.  If~1, return the inside border, otherwise the outside<br/>
		/// border.<br/>
		/// destroy ::<br/>
		/// A Boolean.  If~1, the source glyph object is destroyed on success.<br/>
		/// <br/>
		/// <br/>
		/// Adding stroke may yield a significantly wider and taller glyph<br/>
		/// depending on how large of a radius was used to stroke the glyph.  You<br/>
		/// may need to manually adjust horizontal and vertical advance amounts to<br/>
		/// account for this added size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_StrokeBorder")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphStrokeBorder([NativeName(NativeNameType.Param, "pglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] FTGlyph* pglyph, [NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "inside")] [NativeName(NativeNameType.Type, "FT_Bool")] byte inside, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			FTError ret = GlyphStrokeBorderNative(pglyph, stroker, inside, destroy);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Glyph_StrokeBorder<br/>
		/// <br/>
		/// :<br/>
		/// Stroke a given outline glyph object with a given stroker, but only<br/>
		/// return either its inside or outside border.<br/>
		/// <br/>
		/// :<br/>
		/// pglyph ::<br/>
		/// Source glyph handle on input, new glyph handle on output.<br/>
		/// <br/>
		/// :<br/>
		/// stroker ::<br/>
		/// A stroker handle.<br/>
		/// inside ::<br/>
		/// A Boolean.  If~1, return the inside border, otherwise the outside<br/>
		/// border.<br/>
		/// destroy ::<br/>
		/// A Boolean.  If~1, the source glyph object is destroyed on success.<br/>
		/// <br/>
		/// <br/>
		/// Adding stroke may yield a significantly wider and taller glyph<br/>
		/// depending on how large of a radius was used to stroke the glyph.  You<br/>
		/// may need to manually adjust horizontal and vertical advance amounts to<br/>
		/// account for this added size.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Glyph_StrokeBorder")]
		[return: NativeName(NativeNameType.Type, "FT_Error")]
		public static FTError GlyphStrokeBorder([NativeName(NativeNameType.Param, "pglyph")] [NativeName(NativeNameType.Type, "FT_Glyph *")] ref FTGlyph pglyph, [NativeName(NativeNameType.Param, "stroker")] [NativeName(NativeNameType.Type, "FT_Stroker")] FTStroker stroker, [NativeName(NativeNameType.Param, "inside")] [NativeName(NativeNameType.Type, "FT_Bool")] byte inside, [NativeName(NativeNameType.Param, "destroy")] [NativeName(NativeNameType.Type, "FT_Bool")] byte destroy)
		{
			fixed (FTGlyph* ppglyph = &pglyph)
			{
				FTError ret = GlyphStrokeBorderNative((FTGlyph*)ppglyph, stroker, inside, destroy);
				return ret;
			}
		}

		/// <summary>
		/// Embolden a glyph by a 'reasonable' value (which is highly a matter of <br/>
		/// taste).  This function is actually a convenience function, providing  <br/>
		/// a wrapper for <br/>
		/// _Outline_Embolden and <br/>
		/// _Bitmap_Embolden.           <br/>
		/// <br/>
		/// For emboldened outlines the height, width, and advance metrics are    <br/>
		/// increased by the strength of the emboldening -- this even affects     <br/>
		/// mono-width fonts!                                                     <br/>
		/// <br/>
		/// You can also call <br/>
		/// _Outline_Get_CBox to get precise values.         <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Embolden")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlyphSlotEmboldenNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, void>)funcTable[115])(slot);
			#else
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, void>)funcTable[115])(slot);
			#endif
		}

		/// <summary>
		/// Embolden a glyph by a 'reasonable' value (which is highly a matter of <br/>
		/// taste).  This function is actually a convenience function, providing  <br/>
		/// a wrapper for <br/>
		/// _Outline_Embolden and <br/>
		/// _Bitmap_Embolden.           <br/>
		/// <br/>
		/// For emboldened outlines the height, width, and advance metrics are    <br/>
		/// increased by the strength of the emboldening -- this even affects     <br/>
		/// mono-width fonts!                                                     <br/>
		/// <br/>
		/// You can also call <br/>
		/// _Outline_Get_CBox to get precise values.         <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Embolden")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GlyphSlotEmbolden([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			GlyphSlotEmboldenNative(slot);
		}

		/// <summary>
		/// Precisely adjust the glyph weight either horizontally or vertically.  <br/>
		/// The `xdelta` and `ydelta` values are fractions of the face Em size    <br/>
		/// (in fixed-point format).  Considering that a regular face would have  <br/>
		/// stem widths on the order of 0.1 Em, a delta of 0.05 (0x0CCC) should   <br/>
		/// be very noticeable.  To increase or decrease the weight, use positive <br/>
		/// or negative values, respectively.                                     <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_AdjustWeight")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlyphSlotAdjustWeightNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "xdelta")] [NativeName(NativeNameType.Type, "FT_Fixed")] int xdelta, [NativeName(NativeNameType.Param, "ydelta")] [NativeName(NativeNameType.Type, "FT_Fixed")] int ydelta)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, int, int, void>)funcTable[116])(slot, xdelta, ydelta);
			#else
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, int, int, void>)funcTable[116])(slot, xdelta, ydelta);
			#endif
		}

		/// <summary>
		/// Precisely adjust the glyph weight either horizontally or vertically.  <br/>
		/// The `xdelta` and `ydelta` values are fractions of the face Em size    <br/>
		/// (in fixed-point format).  Considering that a regular face would have  <br/>
		/// stem widths on the order of 0.1 Em, a delta of 0.05 (0x0CCC) should   <br/>
		/// be very noticeable.  To increase or decrease the weight, use positive <br/>
		/// or negative values, respectively.                                     <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_AdjustWeight")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GlyphSlotAdjustWeight([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "xdelta")] [NativeName(NativeNameType.Type, "FT_Fixed")] int xdelta, [NativeName(NativeNameType.Param, "ydelta")] [NativeName(NativeNameType.Type, "FT_Fixed")] int ydelta)
		{
			GlyphSlotAdjustWeightNative(slot, xdelta, ydelta);
		}

		/// <summary>
		/// Slant an outline glyph to the right by about 12 degrees.              <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Oblique")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlyphSlotObliqueNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, void>)funcTable[117])(slot);
			#else
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, void>)funcTable[117])(slot);
			#endif
		}

		/// <summary>
		/// Slant an outline glyph to the right by about 12 degrees.              <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Oblique")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GlyphSlotOblique([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot)
		{
			GlyphSlotObliqueNative(slot);
		}

		/// <summary>
		/// Slant an outline glyph by a given sine of an angle.  You can apply    <br/>
		/// slant along either x- or y-axis by choosing a corresponding non-zero  <br/>
		/// argument.  If both slants are non-zero, some affine transformation    <br/>
		/// will result.                                                          <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Slant")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GlyphSlotSlantNative([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "xslant")] [NativeName(NativeNameType.Type, "FT_Fixed")] int xslant, [NativeName(NativeNameType.Param, "yslant")] [NativeName(NativeNameType.Type, "FT_Fixed")] int yslant)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, int, int, void>)funcTable[118])(slot, xslant, yslant);
			#else
			((delegate* unmanaged[Cdecl]<FTGlyphSlot, int, int, void>)funcTable[118])(slot, xslant, yslant);
			#endif
		}

		/// <summary>
		/// Slant an outline glyph by a given sine of an angle.  You can apply    <br/>
		/// slant along either x- or y-axis by choosing a corresponding non-zero  <br/>
		/// argument.  If both slants are non-zero, some affine transformation    <br/>
		/// will result.                                                          <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_GlyphSlot_Slant")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void GlyphSlotSlant([NativeName(NativeNameType.Param, "slot")] [NativeName(NativeNameType.Type, "FT_GlyphSlot")] FTGlyphSlot slot, [NativeName(NativeNameType.Param, "xslant")] [NativeName(NativeNameType.Type, "FT_Fixed")] int xslant, [NativeName(NativeNameType.Param, "yslant")] [NativeName(NativeNameType.Type, "FT_Fixed")] int yslant)
		{
			GlyphSlotSlantNative(slot, xslant, yslant);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sin<br/>
		/// <br/>
		/// :<br/>
		/// Return the sinus of a given angle in fixed-point format.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sin")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int SinNative([NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[119])(angle);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[119])(angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Sin<br/>
		/// <br/>
		/// :<br/>
		/// Return the sinus of a given angle in fixed-point format.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Sin")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int Sin([NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			int ret = SinNative(angle);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Cos<br/>
		/// <br/>
		/// :<br/>
		/// Return the cosinus of a given angle in fixed-point format.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Cos")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int CosNative([NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[120])(angle);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[120])(angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Cos<br/>
		/// <br/>
		/// :<br/>
		/// Return the cosinus of a given angle in fixed-point format.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Cos")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int Cos([NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			int ret = CosNative(angle);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Tan<br/>
		/// <br/>
		/// :<br/>
		/// Return the tangent of a given angle in fixed-point format.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Tan")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int TanNative([NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int>)funcTable[121])(angle);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int>)funcTable[121])(angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Tan<br/>
		/// <br/>
		/// :<br/>
		/// Return the tangent of a given angle in fixed-point format.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Tan")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int Tan([NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			int ret = TanNative(angle);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Atan2<br/>
		/// <br/>
		/// :<br/>
		/// Return the arc-tangent corresponding to a given vector (x,y) in the 2d<br/>
		/// plane.<br/>
		/// <br/>
		/// :<br/>
		/// x ::<br/>
		/// The horizontal vector coordinate.<br/>
		/// y ::<br/>
		/// The vertical vector coordinate.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Atan2")]
		[return: NativeName(NativeNameType.Type, "FT_Angle")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int Atan2Native([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "FT_Fixed")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "FT_Fixed")] int y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[122])(x, y);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[122])(x, y);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Atan2<br/>
		/// <br/>
		/// :<br/>
		/// Return the arc-tangent corresponding to a given vector (x,y) in the 2d<br/>
		/// plane.<br/>
		/// <br/>
		/// :<br/>
		/// x ::<br/>
		/// The horizontal vector coordinate.<br/>
		/// y ::<br/>
		/// The vertical vector coordinate.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Atan2")]
		[return: NativeName(NativeNameType.Type, "FT_Angle")]
		public static int Atan2([NativeName(NativeNameType.Param, "x")] [NativeName(NativeNameType.Type, "FT_Fixed")] int x, [NativeName(NativeNameType.Param, "y")] [NativeName(NativeNameType.Type, "FT_Fixed")] int y)
		{
			int ret = Atan2Native(x, y);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Angle_Diff<br/>
		/// <br/>
		/// :<br/>
		/// Return the difference between two angles.  The result is always<br/>
		/// constrained to the ]-PI..PI] interval.<br/>
		/// <br/>
		/// :<br/>
		/// angle1 ::<br/>
		/// First angle.<br/>
		/// angle2 ::<br/>
		/// Second angle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Angle_Diff")]
		[return: NativeName(NativeNameType.Type, "FT_Angle")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int AngleDiffNative([NativeName(NativeNameType.Param, "angle1")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle1, [NativeName(NativeNameType.Param, "angle2")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[123])(angle1, angle2);
			#else
			return (int)((delegate* unmanaged[Cdecl]<int, int, int>)funcTable[123])(angle1, angle2);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Angle_Diff<br/>
		/// <br/>
		/// :<br/>
		/// Return the difference between two angles.  The result is always<br/>
		/// constrained to the ]-PI..PI] interval.<br/>
		/// <br/>
		/// :<br/>
		/// angle1 ::<br/>
		/// First angle.<br/>
		/// angle2 ::<br/>
		/// Second angle.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Angle_Diff")]
		[return: NativeName(NativeNameType.Type, "FT_Angle")]
		public static int AngleDiff([NativeName(NativeNameType.Param, "angle1")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle1, [NativeName(NativeNameType.Param, "angle2")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle2)
		{
			int ret = AngleDiffNative(angle1, angle2);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Unit<br/>
		/// <br/>
		/// :<br/>
		/// Return the unit vector corresponding to a given angle.  After the<br/>
		/// call, the value of `vec.x` will be `cos(angle)`, and the value of<br/>
		/// `vec.y` will be `sin(angle)`.<br/>
		/// This function is useful to retrieve both the sinus and cosinus of a<br/>
		/// given angle quickly.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Unit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VectorUnitNative([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTVector*, int, void>)funcTable[124])(vec, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[124])((nint)vec, angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Unit<br/>
		/// <br/>
		/// :<br/>
		/// Return the unit vector corresponding to a given angle.  After the<br/>
		/// call, the value of `vec.x` will be `cos(angle)`, and the value of<br/>
		/// `vec.y` will be `sin(angle)`.<br/>
		/// This function is useful to retrieve both the sinus and cosinus of a<br/>
		/// given angle quickly.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Unit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorUnit([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			VectorUnitNative(vec, angle);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Unit<br/>
		/// <br/>
		/// :<br/>
		/// Return the unit vector corresponding to a given angle.  After the<br/>
		/// call, the value of `vec.x` will be `cos(angle)`, and the value of<br/>
		/// `vec.y` will be `sin(angle)`.<br/>
		/// This function is useful to retrieve both the sinus and cosinus of a<br/>
		/// given angle quickly.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Unit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorUnit([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				VectorUnitNative((FTVector*)pvec, angle);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Rotate<br/>
		/// <br/>
		/// :<br/>
		/// Rotate a vector by a given angle.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Rotate")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VectorRotateNative([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTVector*, int, void>)funcTable[125])(vec, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)funcTable[125])((nint)vec, angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Rotate<br/>
		/// <br/>
		/// :<br/>
		/// Rotate a vector by a given angle.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Rotate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorRotate([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			VectorRotateNative(vec, angle);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Rotate<br/>
		/// <br/>
		/// :<br/>
		/// Rotate a vector by a given angle.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// :<br/>
		/// angle ::<br/>
		/// The input angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Rotate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorRotate([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				VectorRotateNative((FTVector*)pvec, angle);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Length<br/>
		/// <br/>
		/// :<br/>
		/// Return the length of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Length")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int VectorLengthNative([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<FTVector*, int>)funcTable[126])(vec);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)funcTable[126])((nint)vec);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Length<br/>
		/// <br/>
		/// :<br/>
		/// Return the length of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Length")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int VectorLength([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec)
		{
			int ret = VectorLengthNative(vec);
			return ret;
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Length<br/>
		/// <br/>
		/// :<br/>
		/// Return the length of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of target vector.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Length")]
		[return: NativeName(NativeNameType.Type, "FT_Fixed")]
		public static int VectorLength([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec)
		{
			fixed (FTVector* pvec = &vec)
			{
				int ret = VectorLengthNative((FTVector*)pvec);
				return ret;
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VectorPolarizeNative([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] int* length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] int* angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTVector*, int*, int*, void>)funcTable[127])(vec, length, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, void>)funcTable[127])((nint)vec, (nint)length, (nint)angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] int* length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] int* angle)
		{
			VectorPolarizeNative(vec, length, angle);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] int* length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] int* angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				VectorPolarizeNative((FTVector*)pvec, length, angle);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] ref int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] int* angle)
		{
			fixed (int* plength = &length)
			{
				VectorPolarizeNative(vec, (int*)plength, angle);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] ref int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] int* angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				fixed (int* plength = &length)
				{
					VectorPolarizeNative((FTVector*)pvec, (int*)plength, angle);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] int* length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] ref int angle)
		{
			fixed (int* pangle = &angle)
			{
				VectorPolarizeNative(vec, length, (int*)pangle);
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] int* length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] ref int angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				fixed (int* pangle = &angle)
				{
					VectorPolarizeNative((FTVector*)pvec, length, (int*)pangle);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] ref int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] ref int angle)
		{
			fixed (int* plength = &length)
			{
				fixed (int* pangle = &angle)
				{
					VectorPolarizeNative(vec, (int*)plength, (int*)pangle);
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_Polarize<br/>
		/// <br/>
		/// :<br/>
		/// Compute both the length and angle of a given vector.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_Polarize")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorPolarize([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed *")] ref int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle *")] ref int angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				fixed (int* plength = &length)
				{
					fixed (int* pangle = &angle)
					{
						VectorPolarizeNative((FTVector*)pvec, (int*)plength, (int*)pangle);
					}
				}
			}
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_From_Polar<br/>
		/// <br/>
		/// :<br/>
		/// Compute vector coordinates from a length and angle.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_From_Polar")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VectorFromPolarNative([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed")] int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<FTVector*, int, int, void>)funcTable[128])(vec, length, angle);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[128])((nint)vec, length, angle);
			#endif
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_From_Polar<br/>
		/// <br/>
		/// :<br/>
		/// Compute vector coordinates from a length and angle.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_From_Polar")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorFromPolar([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] FTVector* vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed")] int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			VectorFromPolarNative(vec, length, angle);
		}

		/// <summary>
		/// ************************************************************************<br/>
		/// <br/>
		/// FT_Vector_From_Polar<br/>
		/// <br/>
		/// :<br/>
		/// Compute vector coordinates from a length and angle.<br/>
		/// <br/>
		/// :<br/>
		/// vec ::<br/>
		/// The address of source vector.<br/>
		/// <br/>
		/// :<br/>
		/// length ::<br/>
		/// The vector length.<br/>
		/// angle ::<br/>
		/// The vector angle.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "FT_Vector_From_Polar")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void VectorFromPolar([NativeName(NativeNameType.Param, "vec")] [NativeName(NativeNameType.Type, "FT_Vector *")] ref FTVector vec, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "FT_Fixed")] int length, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "FT_Angle")] int angle)
		{
			fixed (FTVector* pvec = &vec)
			{
				VectorFromPolarNative((FTVector*)pvec, length, angle);
			}
		}

	}
}
