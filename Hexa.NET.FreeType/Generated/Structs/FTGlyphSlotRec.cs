// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_GlyphSlotRec<br/>
	/// <br/>
	/// :<br/>
	/// FreeType root glyph slot class structure.  A glyph slot is a container<br/>
	/// where individual glyphs can be loaded, be they in outline or bitmap<br/>
	/// format.<br/>
	/// <br/>
	/// :<br/>
	/// library ::<br/>
	/// A handle to the FreeType library instance this slot belongs to.<br/>
	/// face ::<br/>
	/// A handle to the parent face object.<br/>
	/// next ::<br/>
	/// In some cases (like some font tools), several glyph slots per face<br/>
	/// object can be a good thing.  As this is rare, the glyph slots are<br/>
	/// listed through a direct, single-linked list using its `next` field.<br/>
	/// glyph_index ::<br/>
	/// [Since 2.10] The glyph index passed as an argument to <br/>
	/// _Load_Glyph<br/>
	/// while initializing the glyph slot.<br/>
	/// generic ::<br/>
	/// A typeless pointer unused by the FreeType library or any of its<br/>
	/// drivers.  It can be used by client applications to link their own<br/>
	/// data to each glyph slot object.<br/>
	/// metrics ::<br/>
	/// The metrics of the last loaded glyph in the slot.  The returned<br/>
	/// values depend on the last load flags (see the <br/>
	/// _Load_Glyph API<br/>
	/// function) and can be expressed either in 26.6 fractional pixels or<br/>
	/// font units.<br/>
	/// Note that even when the glyph image is transformed, the metrics are<br/>
	/// not.<br/>
	/// linearHoriAdvance ::<br/>
	/// The advance width of the unhinted glyph.  Its value is expressed in<br/>
	/// 16.16 fractional pixels, unless <br/>
	/// _LOAD_LINEAR_DESIGN is set when<br/>
	/// loading the glyph.  This field can be important to perform correct<br/>
	/// WYSIWYG layout.  Only relevant for scalable glyphs.<br/>
	/// linearVertAdvance ::<br/>
	/// The advance height of the unhinted glyph.  Its value is expressed in<br/>
	/// 16.16 fractional pixels, unless <br/>
	/// _LOAD_LINEAR_DESIGN is set when<br/>
	/// loading the glyph.  This field can be important to perform correct<br/>
	/// WYSIWYG layout.  Only relevant for scalable glyphs.<br/>
	/// advance ::<br/>
	/// This shorthand is, depending on <br/>
	/// _LOAD_IGNORE_TRANSFORM, the<br/>
	/// transformed (hinted) advance width for the glyph, in 26.6 fractional<br/>
	/// pixel format.  As specified with <br/>
	/// _LOAD_VERTICAL_LAYOUT, it uses<br/>
	/// either the `horiAdvance` or the `vertAdvance` value of `metrics`<br/>
	/// field.<br/>
	/// format ::<br/>
	/// This field indicates the format of the image contained in the glyph<br/>
	/// slot.  Typically <br/>
	/// _GLYPH_FORMAT_BITMAP, <br/>
	/// _GLYPH_FORMAT_OUTLINE,<br/>
	/// or <br/>
	/// _GLYPH_FORMAT_COMPOSITE, but other values are possible.<br/>
	/// bitmap ::<br/>
	/// This field is used as a bitmap descriptor.  Note that the address<br/>
	/// and content of the bitmap buffer can change between calls of<br/>
	/// <br/>
	/// _Load_Glyph and a few other functions.<br/>
	/// bitmap_left ::<br/>
	/// The bitmap's left bearing expressed in integer pixels.<br/>
	/// bitmap_top ::<br/>
	/// The bitmap's top bearing expressed in integer pixels.  This is the<br/>
	/// distance from the baseline to the top-most glyph scanline, upwards<br/>
	/// y~coordinates being **positive**.<br/>
	/// outline ::<br/>
	/// The outline descriptor for the current glyph image if its format is<br/>
	/// <br/>
	/// _GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be<br/>
	/// transformed, distorted, emboldened, etc.  However, it must not be<br/>
	/// freed.<br/>
	/// [Since 2.10.1] If <br/>
	/// _LOAD_NO_SCALE is set, outline coordinates of<br/>
	/// OpenType variation fonts for a selected instance are internally<br/>
	/// handled as 26.6 fractional font units but returned as (rounded)<br/>
	/// integers, as expected.  To get unrounded font units, don't use<br/>
	/// <br/>
	/// _LOAD_NO_SCALE but load the glyph with <br/>
	/// _LOAD_NO_HINTING and<br/>
	/// scale it, using the font's `units_per_EM` value as the ppem.<br/>
	/// num_subglyphs ::<br/>
	/// The number of subglyphs in a composite glyph.  This field is only<br/>
	/// valid for the composite glyph format that should normally only be<br/>
	/// loaded with the <br/>
	/// _LOAD_NO_RECURSE flag.<br/>
	/// subglyphs ::<br/>
	/// An array of subglyph descriptors for composite glyphs.  There are<br/>
	/// `num_subglyphs` elements in there.  Currently internal to FreeType.<br/>
	/// control_data ::<br/>
	/// Certain font drivers can also return the control data for a given<br/>
	/// glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).<br/>
	/// This field is a pointer to such data; it is currently internal to<br/>
	/// FreeType.<br/>
	/// control_len ::<br/>
	/// This is the length in bytes of the control data.  Currently internal<br/>
	/// to FreeType.<br/>
	/// other ::<br/>
	/// Reserved.<br/>
	/// lsb_delta ::<br/>
	/// The difference between hinted and unhinted left side bearing while<br/>
	/// auto-hinting is active.  Zero otherwise.<br/>
	/// rsb_delta ::<br/>
	/// The difference between hinted and unhinted right side bearing while<br/>
	/// auto-hinting is active.  Zero otherwise.<br/>
	/// <br/>
	/// This image can later be converted into a bitmap by calling<br/>
	/// <br/>
	/// _Render_Glyph.  This function searches the current renderer for the<br/>
	/// native image's format, then invokes it.<br/>
	/// The renderer is in charge of transforming the native image through the<br/>
	/// slot's face transformation fields, then converting it into a bitmap<br/>
	/// that is returned in `slot->bitmap`.<br/>
	/// Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to<br/>
	/// specify the position of the bitmap relative to the current pen<br/>
	/// position (e.g., coordinates (0,0) on the baseline).  Of course,<br/>
	/// `slot->format` is also changed to <br/>
	/// _GLYPH_FORMAT_BITMAP.<br/>
	/// Here is a small pseudo code fragment that shows how to use `lsb_delta`<br/>
	/// and `rsb_delta` to do fractional positioning of glyphs:<br/>
	/// ```<br/>
	/// FT_GlyphSlot  slot     = face->glyph;<br/>
	/// FT_Pos        origin_x = 0;<br/>
	/// for all glyphs do<br/>
	/// <br/>
	/// <load<br/>
	/// glyph with `FT_Load_Glyph'><br/>
	/// FT_Outline_Translate( slot->outline, origin_x <br/>
	/// &<br/>
	/// 63, 0 );<br/>
	/// <br/>
	/// <save<br/>
	/// glyph image, or render glyph, or ...><br/>
	/// <br/>
	/// <compute<br/>
	/// kern between current and next glyph<br/>
	/// and add it to `origin_x'><br/>
	/// origin_x += slot->advance.x;<br/>
	/// origin_x += slot->lsb_delta - slot->rsb_delta;<br/>
	/// endfor<br/>
	/// ```<br/>
	/// Here is another small pseudo code fragment that shows how to use<br/>
	/// `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:<br/>
	/// ```<br/>
	/// FT_GlyphSlot  slot           = face->glyph;<br/>
	/// FT_Pos        origin_x       = 0;<br/>
	/// FT_Pos        prev_rsb_delta = 0;<br/>
	/// for all glyphs do<br/>
	/// <br/>
	/// <compute<br/>
	/// kern between current and previous glyph<br/>
	/// and add it to `origin_x'><br/>
	/// <br/>
	/// <load<br/>
	/// glyph with `FT_Load_Glyph'><br/>
	/// if ( prev_rsb_delta - slot->lsb_delta >  32 )<br/>
	/// origin_x -= 64;<br/>
	/// else if ( prev_rsb_delta - slot->lsb_delta <br/>
	/// <<br/>
	/// -31 )<br/>
	/// origin_x += 64;<br/>
	/// prev_rsb_delta = slot->rsb_delta;<br/>
	/// <br/>
	/// <save<br/>
	/// glyph image, or render glyph, or ...><br/>
	/// origin_x += slot->advance.x;<br/>
	/// endfor<br/>
	/// ```<br/>
	/// If you use strong auto-hinting, you **must** apply these delta values!<br/>
	/// Otherwise you will experience far too large inter-glyph spacing at<br/>
	/// small rendering sizes in most cases.  Note that it doesn't harm to use<br/>
	/// the above code for other hinting modes also, since the delta values<br/>
	/// are zero then.<br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_GlyphSlotRec_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTGlyphSlotRec
	{
		[NativeName(NativeNameType.Field, "library")]
		[NativeName(NativeNameType.Type, "FT_Library")]
		public FTLibrary Library;
		[NativeName(NativeNameType.Field, "face")]
		[NativeName(NativeNameType.Type, "FT_FaceRec_ *")]
		public unsafe FTFaceRec* Face;
		[NativeName(NativeNameType.Field, "next")]
		[NativeName(NativeNameType.Type, "FT_GlyphSlotRec_ *")]
		public unsafe FTGlyphSlotRec* Next;
		/// <summary>
		/// new in 2.10; was reserved previously <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "glyph_index")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint GlyphIndex;

		[NativeName(NativeNameType.Field, "generic")]
		[NativeName(NativeNameType.Type, "FT_Generic")]
		public FTGeneric Generic;
		[NativeName(NativeNameType.Field, "metrics")]
		[NativeName(NativeNameType.Type, "FT_Glyph_Metrics")]
		public FTGlyphMetrics Metrics;
		[NativeName(NativeNameType.Field, "linearHoriAdvance")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int LinearHoriAdvance;
		[NativeName(NativeNameType.Field, "linearVertAdvance")]
		[NativeName(NativeNameType.Type, "FT_Fixed")]
		public int LinearVertAdvance;
		[NativeName(NativeNameType.Field, "advance")]
		[NativeName(NativeNameType.Type, "FT_Vector")]
		public FTVector Advance;
		[NativeName(NativeNameType.Field, "format")]
		[NativeName(NativeNameType.Type, "FT_Glyph_Format")]
		public FTGlyphFormat Format;
		[NativeName(NativeNameType.Field, "bitmap")]
		[NativeName(NativeNameType.Type, "FT_Bitmap")]
		public FTBitmap Bitmap;
		[NativeName(NativeNameType.Field, "bitmap_left")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int BitmapLeft;
		[NativeName(NativeNameType.Field, "bitmap_top")]
		[NativeName(NativeNameType.Type, "FT_Int")]
		public int BitmapTop;
		[NativeName(NativeNameType.Field, "outline")]
		[NativeName(NativeNameType.Type, "FT_Outline")]
		public FTOutline Outline;
		[NativeName(NativeNameType.Field, "num_subglyphs")]
		[NativeName(NativeNameType.Type, "FT_UInt")]
		public uint NumSubglyphs;
		[NativeName(NativeNameType.Field, "subglyphs")]
		[NativeName(NativeNameType.Type, "FT_SubGlyphRec_ *")]
		public unsafe FTSubGlyphRec* Subglyphs;
		[NativeName(NativeNameType.Field, "control_data")]
		[NativeName(NativeNameType.Type, "void *")]
		public unsafe void* ControlData;
		[NativeName(NativeNameType.Field, "control_len")]
		[NativeName(NativeNameType.Type, "long")]
		public int ControlLen;
		[NativeName(NativeNameType.Field, "lsb_delta")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int LsbDelta;
		[NativeName(NativeNameType.Field, "rsb_delta")]
		[NativeName(NativeNameType.Type, "FT_Pos")]
		public int RsbDelta;
		[NativeName(NativeNameType.Field, "other")]
		[NativeName(NativeNameType.Type, "void *")]
		public unsafe void* Other;
		[NativeName(NativeNameType.Field, "internal")]
		[NativeName(NativeNameType.Type, "FT_Slot_InternalRec_ *")]
		public unsafe FTSlotInternalRec* Internal;

		public unsafe FTGlyphSlotRec(FTLibrary library = default, FTFaceRec* face = default, FTGlyphSlotRec* next = default, uint glyphIndex = default, FTGeneric generic = default, FTGlyphMetrics metrics = default, int linearHoriAdvance = default, int linearVertAdvance = default, FTVector advance = default, FTGlyphFormat format = default, FTBitmap bitmap = default, int bitmapLeft = default, int bitmapTop = default, FTOutline outline = default, uint numSubglyphs = default, FTSubGlyphRec* subglyphs = default, void* controlData = default, int controlLen = default, int lsbDelta = default, int rsbDelta = default, void* other = default, FTSlotInternalRec* @internal = default)
		{
			Library = library;
			Face = face;
			Next = next;
			GlyphIndex = glyphIndex;
			Generic = generic;
			Metrics = metrics;
			LinearHoriAdvance = linearHoriAdvance;
			LinearVertAdvance = linearVertAdvance;
			Advance = advance;
			Format = format;
			Bitmap = bitmap;
			BitmapLeft = bitmapLeft;
			BitmapTop = bitmapTop;
			Outline = outline;
			NumSubglyphs = numSubglyphs;
			Subglyphs = subglyphs;
			ControlData = controlData;
			ControlLen = controlLen;
			LsbDelta = lsbDelta;
			RsbDelta = rsbDelta;
			Other = other;
			Internal = @internal;
		}


	}

}
