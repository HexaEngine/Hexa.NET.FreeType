// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;

namespace Hexa.NET.FreeType
{
	/// <summary>
	/// ************************************************************************<br/>
	/// <br/>
	/// FT_Outline<br/>
	/// <br/>
	/// :<br/>
	/// This structure is used to describe an outline to the scan-line<br/>
	/// converter.<br/>
	/// <br/>
	/// :<br/>
	/// n_contours ::<br/>
	/// The number of contours in the outline.<br/>
	/// n_points ::<br/>
	/// The number of points in the outline.<br/>
	/// points ::<br/>
	/// A pointer to an array of `n_points` <br/>
	/// _Vector elements, giving the<br/>
	/// outline's point coordinates.<br/>
	/// tags ::<br/>
	/// A pointer to an array of `n_points` chars, giving each outline<br/>
	/// point's type.<br/>
	/// If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier<br/>
	/// control point, while it is 'on' if set.<br/>
	/// Bit~1 is meaningful for 'off' points only.  If set, it indicates a<br/>
	/// third-order Bezier arc control point; and a second-order control<br/>
	/// point if unset.<br/>
	/// If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in<br/>
	/// the OpenType specification; the value is the same as the argument to<br/>
	/// the 'SCANTYPE' instruction).<br/>
	/// Bits 3 and~4 are reserved for internal purposes.<br/>
	/// contours ::<br/>
	/// An array of `n_contours` shorts, giving the end point of each<br/>
	/// contour within the outline.  For example, the first contour is<br/>
	/// defined by the points '0' to `contours[0]`, the second one is<br/>
	/// defined by the points `contours[0]+1` to `contours[1]`, etc.<br/>
	/// flags ::<br/>
	/// A set of bit flags used to characterize the outline and give hints<br/>
	/// to the scan-converter and hinter on how to convert/grid-fit it.  See<br/>
	/// <br/>
	/// _OUTLINE_XXX.<br/>
	/// <br/>
	/// </summary>
	[NativeName(NativeNameType.StructOrClass, "FT_Outline_")]
	[StructLayout(LayoutKind.Sequential)]
	public partial struct FTOutline
	{
		/// <summary>
		/// number of contours in glyph        <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "n_contours")]
		[NativeName(NativeNameType.Type, "unsigned short")]
		public ushort NContours;

		/// <summary>
		/// number of points in the glyph      <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "n_points")]
		[NativeName(NativeNameType.Type, "unsigned short")]
		public ushort NPoints;

		/// <summary>
		/// the outline's points               <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "points")]
		[NativeName(NativeNameType.Type, "FT_Vector *")]
		public unsafe FTVector* Points;

		/// <summary>
		/// the points flags                   <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "tags")]
		[NativeName(NativeNameType.Type, "unsigned char *")]
		public unsafe byte* Tags;

		/// <summary>
		/// the contour end points             <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "contours")]
		[NativeName(NativeNameType.Type, "unsigned short *")]
		public unsafe ushort* Contours;

		/// <summary>
		/// outline masks                      <br/>
		/// </summary>
		[NativeName(NativeNameType.Field, "flags")]
		[NativeName(NativeNameType.Type, "int")]
		public int Flags;


		public unsafe FTOutline(ushort nContours = default, ushort nPoints = default, FTVector* points = default, byte* tags = default, ushort* contours = default, int flags = default)
		{
			NContours = nContours;
			NPoints = nPoints;
			Points = points;
			Tags = tags;
			Contours = contours;
			Flags = flags;
		}


	}

}
